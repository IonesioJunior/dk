<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat - Syft Agent</title>
    <style>
        .chat-wrapper {
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 0;
            margin: 0;
            background-color: transparent;
            overflow: hidden;
            position: relative;
        }
        
        .chat-controls {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            z-index: 10;
        }
        
        .clear-button {
            padding: 0.5rem 1rem;
            background-color: #f3f4f6;
            color: #374151;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        
        body.dark .clear-button {
            background-color: #374151;
            color: #f3f4f6;
            border-color: #4b5563;
        }
        
        .clear-button:hover {
            background-color: #e5e7eb;
        }
        
        body.dark .clear-button:hover {
            background-color: #4b5563;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 0;
            min-height: 0;
        }
        
        .message-wrapper {
            padding: 0.75rem 0;
            background-color: transparent;
        }
        
        .message-content {
            max-width: 48rem;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            gap: 1.5rem;
            transition: background-color 0.2s ease, padding 0.2s ease;
            cursor: pointer;
            border-radius: 0.5rem;
        }
        
        .message-content:hover {
            background-color: rgba(249, 250, 251, 0.8);
            padding: 0.75rem 1rem;
        }
        
        body.dark .message-content:hover {
            background-color: rgba(31, 41, 55, 0.6);
        }
        
        .avatar {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .avatar.user {
            background-color: #f3f4f6;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        
        .avatar.assistant {
            background-color: #4a90e2;
            color: white;
        }
        
        body.dark .avatar.user {
            background-color: #374151;
            color: #f3f4f6;
            border: 1px solid #4b5563;
        }
        
        body.dark .avatar.assistant {
            background-color: #2563eb;
            color: white;
        }
        
        .message-text {
            line-height: 1.75;
            flex: 1;
            color: #1f2937;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        body.dark .message-text {
            color: #e5e7eb;
        }
        
        .message-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        
        .message-name {
            font-weight: 600;
            font-size: 0.875rem;
        }
        
        .message-name.user {
            color: #2563eb;
        }
        
        .message-name.assistant {
            color: #059669;
        }
        
        body.dark .message-name.user {
            color: #60a5fa;
        }
        
        body.dark .message-name.assistant {
            color: #34d399;
        }
        
        .message-time {
            font-size: 0.75rem;
            color: #9ca3af;
        }
        
        body.dark .message-time {
            color: #6b7280;
        }
        
        .chat-input-wrapper {
            padding: 1rem 0 1.5rem;
            background-color: transparent;
            position: relative;
            flex-shrink: 0;
        }
        
        .chat-input-container {
            max-width: 48rem;
            margin: 0 auto;
            padding: 0 1rem;
            position: relative;
        }
        
        .input-box {
            width: 100%;
            display: flex;
            align-items: center;
            border: 1px solid #d9d9e3;
            border-radius: 0.75rem;
            background-color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s;
        }
        
        body.dark .input-box {
            background-color: #2a2b32;
            border-color: #565869;
        }
        
        .input-box:focus-within {
            border-color: #4a90e2;
        }
        
        .chat-input {
            flex: 1;
            padding: 0.875rem 1rem;
            font-size: 1rem;
            border: none;
            background: transparent;
            outline: none;
            resize: none;
            line-height: 1.5;
            min-height: 24px;
            max-height: 120px;
        }
        
        body.dark .chat-input {
            color: #ececf1;
        }
        
        .chat-input::placeholder {
            color: #8e8ea0;
        }
        
        body.dark .chat-input::placeholder {
            color: #acacbe;
        }
        
        .send-button {
            padding: 0.5rem;
            margin: 0.5rem;
            background-color: transparent;
            color: #8e8ea0;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .send-button:hover:not(:disabled) {
            background-color: #f0f0f0;
            color: #333;
        }
        
        body.dark .send-button:hover:not(:disabled) {
            background-color: #565869;
            color: #ececf1;
        }
        
        .send-button.active {
            background-color: #4a90e2;
            color: white;
        }
        
        .send-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .typing-indicator {
            display: none;
        }
        
        .typing-indicator.active {
            display: block;
        }
        
        .typing-dots {
            display: inline-flex;
            gap: 4px;
            align-items: center;
        }
        
        .typing-dots span {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #666;
            animation: typing 1.4s infinite;
        }
        
        body.dark .typing-dots span {
            background-color: #999;
        }
        
        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-10px);
            }
        }
        
        
        
        /* Scrollbar styling - minimalist and modern */
        .chat-messages::-webkit-scrollbar {
            width: 4px;
        }
        
        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(156, 163, 175, 0.3);
            border-radius: 999px;
            transition: background 0.2s ease;
        }
        
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(156, 163, 175, 0.5);
        }
        
        body.dark .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
        }
        
        body.dark .chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Firefox scrollbar support */
        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
        }
        
        body.dark * {
            scrollbar-color: rgba(255, 255, 255, 0.1) transparent;
        }
        
        /* Mention suggestion popup styles */
        .mention-popup {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 20;
            max-height: 12rem;
            overflow-y: auto;
            display: none;
            bottom: 100%;
            left: 0;
            width: 200px;
            margin-bottom: 0.5rem;
        }
        
        body.dark .mention-popup {
            background: #2a2b32;
            border-color: #565869;
        }
        
        .mention-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background-color 0.15s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .mention-item:hover,
        .mention-item.selected {
            background-color: #f3f4f6;
        }
        
        body.dark .mention-item:hover,
        body.dark .mention-item.selected {
            background-color: #374151;
        }
        
        .mention-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #4a90e2;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            position: relative;
        }
        
        .online-indicator {
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #10b981;
            border: 2px solid white;
        }
        
        body.dark .online-indicator {
            border-color: #2a2b32;
        }
        
        .mention-name {
            font-size: 0.875rem;
            color: #374151;
        }
        
        body.dark .mention-name {
            color: #e5e7eb;
        }
        
        .mention-item.offline .mention-avatar {
            opacity: 0.7;
        }
        
        .mention-item.offline .mention-name {
            opacity: 0.7;
        }
        
        /* Slash command popup styles */
        .slash-popup {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 20;
            max-height: 16rem;
            overflow-y: auto;
            display: none;
            bottom: 100%;
            left: 0;
            right: 0;
            margin-bottom: 0.5rem;
        }
        
        body.dark .slash-popup {
            background: #2a2b32;
            border-color: #565869;
        }
        
        .slash-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background-color 0.15s;
            border-bottom: 1px solid #f3f4f6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }
        
        body.dark .slash-item {
            border-bottom-color: #374151;
        }
        
        .slash-item:last-child {
            border-bottom: none;
        }
        
        .slash-item:hover,
        .slash-item.selected {
            background-color: #f3f4f6;
        }
        
        body.dark .slash-item:hover,
        body.dark .slash-item.selected {
            background-color: #374151;
        }
        
        .slash-command {
            font-weight: 600;
            font-size: 0.875rem;
            color: #2563eb;
            flex-shrink: 0;
        }
        
        body.dark .slash-command {
            color: #60a5fa;
        }
        
        .slash-description {
            font-size: 0.75rem;
            color: #6b7280;
            line-height: 1.3;
            text-align: right;
        }
        
        body.dark .slash-description {
            color: #9ca3af;
        }
        
        /* Response counter tag styles */
        .response-counter {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.125rem 0.5rem;
            background-color: #e5e7eb;
            color: #6b7280;
            font-size: 0.75rem;
            font-weight: 500;
            border-radius: 0.375rem;
            margin-left: 0.5rem;
        }
        
        body.dark .response-counter {
            background-color: #374151;
            color: #9ca3af;
        }
        
        .response-counter i {
            width: 14px;
            height: 14px;
        }
    </style>
</head>
<body>
    <div class="chat-wrapper">
        <div class="chat-controls">
            <button class="clear-button" id="clear-conversation">New Conversation</button>
        </div>
        <div class="chat-messages" id="chat-messages">
            <div class="message-wrapper assistant">
                <div class="message-content">
                    <div class="avatar assistant">AI</div>
                    <div style="flex: 1;">
                        <div class="message-header">
                            <div class="message-name assistant">AI Assistant</div>
                            <div class="message-time" id="greeting-time"></div>
                        </div>
                        <div class="message-text">Hello! How can I help you today?</div>
                    </div>
                </div>
            </div>
            
            <div class="typing-indicator message-wrapper assistant" id="typing-indicator">
                <div class="message-content">
                    <div class="avatar assistant">AI</div>
                    <div class="message-text">
                        <div class="typing-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="chat-input-wrapper">
            <div class="chat-input-container">
                <div class="input-box">
                    <textarea 
                        class="chat-input" 
                        id="chat-input" 
                        placeholder="Send a message..."
                        rows="1"
                    ></textarea>
                    <button class="send-button" id="send-button">
                        <i data-lucide="send" style="width: 20px; height: 20px;"></i>
                    </button>
                </div>
                <div class="mention-popup" id="mention-popup"></div>
                <div class="slash-popup" id="slash-popup"></div>
            </div>
        </div>
    </div>
    
    <script>
        window.initializeChatPage = function() {
            // Initialize Lucide icons
            lucide.createIcons();
            
            // Centralized state management
            const state = {
                // UI States
                mentionActive: false,
                mentionStartPosition: -1,
                selectedMentionIndex: 0,
                filteredUsers: [],
                slashActive: false,
                slashStartPosition: -1,
                selectedSlashIndex: 0,
                filteredCommands: [],
                
                // Request States
                pendingRequest: null,
                requestAbortController: null,
                isProcessingMessage: false,
                pendingResponses: new Map(),
                
                // Data
                allUsers: [],
                currentUserId: null,
                messageRefs: new Map(),
                
                // Event Listeners
                eventListeners: []
            };
            
            // Mock slash commands
            const mockCommands = [
                { command: '/help', description: 'Show available commands and how to use them' },
                { command: '/clear', description: 'Clear the current conversation' },
                { command: '/model', description: 'Change the AI model being used' },
                { command: '/settings', description: 'Open settings and configuration' },
                { command: '/export', description: 'Export conversation history' },
                { command: '/system', description: 'Set system prompt for the AI' },
                { command: '/temperature', description: 'Adjust response randomness (0-1)' },
                { command: '/history', description: 'View previous conversations' },
                { command: '/search', description: 'Search through message history' },
                { command: '/theme', description: 'Toggle between light and dark mode' }
            ];
            
            // DOM references
            const chatMessages = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('send-button');
            const typingIndicator = document.getElementById('typing-indicator');
            const mentionPopup = document.getElementById('mention-popup');
            const slashPopup = document.getElementById('slash-popup');
            const clearButton = document.getElementById('clear-conversation');
            
            // Debounced fetch users function
            const debouncedFetchUsers = debounce(fetchActiveUsers, 300);
            
            // Utility function for debouncing
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
            
            // Simple mutex implementation
            class Mutex {
                constructor() {
                    this.locked = false;
                    this.waiting = [];
                }
                
                async acquire() {
                    while (this.locked) {
                        await new Promise(resolve => this.waiting.push(resolve));
                    }
                    this.locked = true;
                }
                
                release() {
                    this.locked = false;
                    if (this.waiting.length > 0) {
                        const resolve = this.waiting.shift();
                        resolve();
                    }
                }
            }
            
            const sendMessageMutex = new Mutex();
            const popupMutex = new Mutex();
            
            // Fetch active users from the API
            async function fetchActiveUsers() {
                try {
                    const response = await fetch('/api/active-users');
                    if (response.ok) {
                        const data = await response.json();
                        
                        // Store the current user ID
                        state.currentUserId = data.current_user_id;
                        
                        // Convert API response to our user format
                        state.allUsers = [];
                        
                        // Add online users (excluding current user)
                        if (data.online && Array.isArray(data.online)) {
                            data.online.forEach((username, index) => {
                                if (username !== state.currentUserId) {
                                    state.allUsers.push({
                                        id: index + 1,
                                        name: username,
                                        avatar: username.substring(0, 2).toUpperCase(),
                                        online: true
                                    });
                                }
                            });
                        }
                        
                        // Add offline users (excluding current user)
                        if (data.offline && Array.isArray(data.offline)) {
                            data.offline.forEach((username, index) => {
                                if (username !== state.currentUserId) {
                                    state.allUsers.push({
                                        id: data.online.length + index + 1,
                                        name: username,
                                        avatar: username.substring(0, 2).toUpperCase(),
                                        online: false
                                    });
                                }
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error fetching active users:', error);
                    // Fallback to empty array if API fails
                    state.allUsers = [];
                }
            }
            
            // These variables have been moved to state object
            
            // Update mention popup
            async function updateMentionPopup(filter = '') {
                await popupMutex.acquire();
                try {
                    // Refresh user list from API when opening mention popup
                    await debouncedFetchUsers();
                    
                    state.filteredUsers = state.allUsers.filter(user => 
                        user.name.toLowerCase().includes(filter.toLowerCase())
                    );
                    
                    if (state.filteredUsers.length === 0) {
                        hideMentionPopup();
                        return;
                    }
                    
                    mentionPopup.innerHTML = '';
                    state.filteredUsers.forEach((user, index) => {
                        const item = document.createElement('div');
                        item.className = 'mention-item' + (index === state.selectedMentionIndex ? ' selected' : '') + (!user.online ? ' offline' : '');
                        
                        const avatar = document.createElement('div');
                        avatar.className = 'mention-avatar';
                        avatar.textContent = user.avatar;
                        
                        // Add online indicator for online users
                        if (user.online) {
                            const onlineIndicator = document.createElement('div');
                            onlineIndicator.className = 'online-indicator';
                            avatar.appendChild(onlineIndicator);
                        }
                        
                        const name = document.createElement('div');
                        name.className = 'mention-name';
                        name.textContent = user.name;
                        
                        item.appendChild(avatar);
                        item.appendChild(name);
                        
                        item.addEventListener('click', () => {
                            insertMention(user);
                        });
                        
                        mentionPopup.appendChild(item);
                    });
                    
                    showMentionPopup();
                } finally {
                    popupMutex.release();
                }
            }
            
            // Show mention popup
            function showMentionPopup() {
                mentionPopup.style.display = 'block';
            }
            
            // Hide mention popup
            function hideMentionPopup() {
                mentionPopup.style.display = 'none';
                state.mentionActive = false;
                state.mentionStartPosition = -1;
                state.selectedMentionIndex = 0;
            }
            
            // Insert mention
            function insertMention(user) {
                const text = chatInput.value;
                const beforeMention = text.substring(0, state.mentionStartPosition);
                const afterMention = text.substring(chatInput.selectionStart);
                
                chatInput.value = beforeMention + '@' + user.name + ' ' + afterMention;
                const cursorPosition = beforeMention.length + user.name.length + 2;
                chatInput.setSelectionRange(cursorPosition, cursorPosition);
                
                hideMentionPopup();
                autoResize();
                updateSendButton();
                chatInput.focus();
            }
            
            // Update slash command popup
            async function updateSlashPopup(filter = '') {
                await popupMutex.acquire();
                try {
                    state.filteredCommands = mockCommands.filter(cmd => 
                        cmd.command.toLowerCase().includes(filter.toLowerCase())
                    );
                    
                    if (state.filteredCommands.length === 0) {
                        hideSlashPopup();
                        return;
                    }
                    
                    slashPopup.innerHTML = '';
                    state.filteredCommands.forEach((cmd, index) => {
                        const item = document.createElement('div');
                        item.className = 'slash-item' + (index === state.selectedSlashIndex ? ' selected' : '');
                        
                        const command = document.createElement('div');
                        command.className = 'slash-command';
                        command.textContent = cmd.command;
                        
                        const description = document.createElement('div');
                        description.className = 'slash-description';
                        description.textContent = cmd.description;
                        
                        item.appendChild(command);
                        item.appendChild(description);
                        
                        item.addEventListener('click', () => {
                            insertSlashCommand(cmd);
                        });
                        
                        slashPopup.appendChild(item);
                    });
                    
                    showSlashPopup();
                } finally {
                    popupMutex.release();
                }
            }
            
            // Show slash command popup
            function showSlashPopup() {
                slashPopup.style.display = 'block';
            }
            
            // Hide slash command popup
            function hideSlashPopup() {
                slashPopup.style.display = 'none';
                state.slashActive = false;
                state.slashStartPosition = -1;
                state.selectedSlashIndex = 0;
            }
            
            // Insert slash command
            function insertSlashCommand(cmd) {
                const text = chatInput.value;
                const beforeSlash = text.substring(0, state.slashStartPosition);
                const afterSlash = text.substring(chatInput.selectionStart);
                
                chatInput.value = beforeSlash + cmd.command + ' ' + afterSlash;
                const cursorPosition = beforeSlash.length + cmd.command.length + 1;
                chatInput.setSelectionRange(cursorPosition, cursorPosition);
                
                hideSlashPopup();
                autoResize();
                updateSendButton();
                chatInput.focus();
            }
            
            // Auto-resize textarea
            function autoResize() {
                chatInput.style.height = 'auto';
                chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
                updateSendButton();
            }
            
            // Update send button state
            function updateSendButton() {
                if (chatInput.value.trim()) {
                    sendButton.classList.add('active');
                    sendButton.disabled = false;
                } else {
                    sendButton.classList.remove('active');
                    sendButton.disabled = true;
                }
            }
            
            // Auto-scroll to bottom of messages
            function scrollToBottom() {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            // Add message to chat
            function addMessage(content, isUser = false, timestamp = null) {
                const messageWrapper = document.createElement('div');
                messageWrapper.className = `message-wrapper ${isUser ? 'user' : 'assistant'}`;
                
                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';
                
                const avatar = document.createElement('div');
                avatar.className = `avatar ${isUser ? 'user' : 'assistant'}`;
                avatar.textContent = isUser ? 'U' : 'AI';
                
                const messageTextWrapper = document.createElement('div');
                messageTextWrapper.style.flex = '1';
                
                // Create header with name and timestamp
                const messageHeader = document.createElement('div');
                messageHeader.className = 'message-header';
                
                const messageName = document.createElement('div');
                messageName.className = `message-name ${isUser ? 'user' : 'assistant'}`;
                messageName.textContent = isUser ? 'User' : 'AI Assistant';
                
                const messageTime = document.createElement('div');
                messageTime.className = 'message-time';
                
                if (timestamp) {
                    // Parse and format existing timestamp
                    const date = new Date(timestamp);
                    messageTime.textContent = formatTime(date);
                } else {
                    // Use current time for new messages
                    messageTime.textContent = formatTime(new Date());
                }
                
                messageHeader.appendChild(messageName);
                messageHeader.appendChild(messageTime);
                
                const messageText = document.createElement('div');
                messageText.className = 'message-text';
                messageText.textContent = content;
                
                messageTextWrapper.appendChild(messageHeader);
                messageTextWrapper.appendChild(messageText);
                
                messageContent.appendChild(avatar);
                messageContent.appendChild(messageTextWrapper);
                messageWrapper.appendChild(messageContent);
                
                // Insert at the end of messages, but before typing indicator if it exists
                const lastMessage = chatMessages.querySelector('.message-wrapper:last-child');
                if (lastMessage && lastMessage.id === 'typing-indicator') {
                    chatMessages.insertBefore(messageWrapper, lastMessage);
                } else {
                    chatMessages.appendChild(messageWrapper);
                }
                scrollToBottom();
            }
            
            // Format time for display
            function formatTime(date) {
                const now = new Date();
                const isToday = date.toDateString() === now.toDateString();
                
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes().toString().padStart(2, '0');
                const time = `${hours}:${minutes}`;
                
                if (isToday) {
                    return time;
                } else {
                    const month = date.toLocaleDateString('en-US', { month: 'short' });
                    const day = date.getDate();
                    return `${month} ${day}, ${time}`;
                }
            }
            
            // Extract mentions from message
            function extractMentions(message) {
                const mentionPattern = /@([a-zA-Z0-9_-]+)(?=\s|$|[.,!?])/g;
                const mentions = [];
                let match;
                
                while ((match = mentionPattern.exec(message)) !== null) {
                    const mention = match[1].trim();
                    if (mention && !mentions.includes(mention)) {
                        mentions.push(mention);
                    }
                }
                
                return mentions;
            }
            
            // Show typing indicator
            function showTyping() {
                typingIndicator.classList.add('active');
                scrollToBottom();
            }
            
            // Hide typing indicator
            function hideTyping() {
                typingIndicator.classList.remove('active');
            }
            
            // Create AI message element with typing animation
            function createAIMessage(mentionCount = 0) {
                const messageWrapper = document.createElement('div');
                messageWrapper.className = 'message-wrapper assistant';
                
                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';
                
                const avatar = document.createElement('div');
                avatar.className = 'avatar assistant';
                avatar.textContent = 'AI';
                
                const messageTextWrapper = document.createElement('div');
                messageTextWrapper.style.flex = '1';
                
                // Create header with name and timestamp
                const messageHeader = document.createElement('div');
                messageHeader.className = 'message-header';
                
                const messageName = document.createElement('div');
                messageName.className = 'message-name assistant';
                messageName.textContent = 'AI Assistant';
                
                const messageTime = document.createElement('div');
                messageTime.className = 'message-time';
                messageTime.textContent = formatTime(new Date());
                
                messageHeader.appendChild(messageName);
                messageHeader.appendChild(messageTime);
                
                // Add response counter if this is a mention query
                let responseCounter = null;
                if (mentionCount > 0) {
                    responseCounter = document.createElement('div');
                    responseCounter.className = 'response-counter';
                    responseCounter.innerHTML = '<i data-lucide="user" style="width: 14px; height: 14px;"></i><span style="margin-left: 0.25rem;">0/' + mentionCount + '</span>';
                    messageHeader.appendChild(responseCounter);
                }
                
                const messageElement = document.createElement('div');
                messageElement.className = 'message-text';
                
                // Start with typing dots animation
                const typingDots = document.createElement('div');
                typingDots.className = 'typing-dots';
                typingDots.innerHTML = '<span></span><span></span><span></span>';
                messageElement.appendChild(typingDots);
                
                messageTextWrapper.appendChild(messageHeader);
                messageTextWrapper.appendChild(messageElement);
                
                messageContent.appendChild(avatar);
                messageContent.appendChild(messageTextWrapper);
                messageWrapper.appendChild(messageContent);
                
                // Insert at the end of messages, but before typing indicator if it exists
                const lastMessage = chatMessages.querySelector('.message-wrapper:last-child');
                if (lastMessage && lastMessage.id === 'typing-indicator') {
                    chatMessages.insertBefore(messageWrapper, lastMessage);
                } else {
                    chatMessages.appendChild(messageWrapper);
                }
                scrollToBottom();
                
                // Initialize icons if we have a response counter
                if (responseCounter) {
                    setTimeout(() => {
                        lucide.createIcons({
                            container: responseCounter
                        });
                    }, 0);
                }
                
                // Return references for updating
                return {
                    messageElement,
                    responseCounter,
                    typingDots
                };
            }
            
            // Update AI message content
            function updateAIMessage(messageRefs, content) {
                const { messageElement, typingDots } = messageRefs;
                
                // Remove typing dots if they exist
                if (typingDots && typingDots.parentNode === messageElement) {
                    messageElement.removeChild(typingDots);
                }
                
                // Update content
                messageElement.textContent = content;
                scrollToBottom();
            }
            
            // Update response counter
            function updateResponseCounter(messageRefs, responseCount, totalMentions) {
                const { responseCounter } = messageRefs;
                if (responseCounter) {
                    responseCounter.querySelector('span').textContent = responseCount + '/' + totalMentions;
                }
            }
            
            // Poll for responses with exponential backoff
            async function pollForResponses(promptId, messageRefs, mentions) {
                let attempts = 0;
                const maxAttempts = 10;
                let delay = 1000; // Start with 1 second
                
                while (attempts < maxAttempts) {
                    try {
                        const response = await fetch(`/api/prompt-responses/${promptId}`, {
                            credentials: 'same-origin'
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            
                            if (data.responses && data.responses.length > 0) {
                                return data.responses;
                            }
                        }
                        
                        attempts++;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay = Math.min(delay * 1.5, 5000); // Exponential backoff, max 5 seconds
                    } catch (error) {
                        console.error('Error polling for responses:', error);
                        attempts++;
                    }
                }
                
                return null;
            }
            
            // Send message
            async function sendMessage() {
                await sendMessageMutex.acquire();
                
                try {
                    const message = chatInput.value.trim();
                    if (!message) return;
                    
                    // Cancel any existing request
                    if (state.requestAbortController) {
                        state.requestAbortController.abort();
                    }
                    
                    // Extract mentions from the message
                    const mentions = extractMentions(message);
                    
                    // Add user message
                    addMessage(message, true);
                    chatInput.value = '';
                    autoResize();
                    chatInput.disabled = true;
                    sendButton.disabled = true;
                    
                    // Show typing indicator
                    showTyping();
                    
                    // Create new abort controller for this request
                    state.requestAbortController = new AbortController();
                    state.isProcessingMessage = true;
                
                try {
                    // Determine which endpoint to use based on mentions
                    const endpoint = mentions.length > 0 ? '/api/query_peers' : '/api/query';
                    const requestBody = mentions.length > 0 
                        ? { message: message, peers: mentions }
                        : { message: message };
                    
                    // Send to API endpoint with credentials for cookies
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        credentials: 'same-origin',  // Include cookies
                        body: JSON.stringify(requestBody),
                        signal: state.requestAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    // Handle response based on endpoint
                    if (mentions.length > 0) {
                        // Handle query_peers response (returns prompt_id)
                        const data = await response.json();
                        
                        if (data.status === 'success' && data.prompt_id) {
                            // Hide typing indicator and create AI message
                            hideTyping();
                            const messageRefs = createAIMessage(mentions.length);
                            
                            // Update message to show gathering responses
                            updateAIMessage(messageRefs, 'Gathering responses from peers...');
                            
                            // Poll for responses with exponential backoff
                            const responses = await pollForResponses(data.prompt_id, messageRefs, mentions);
                            
                            if (responses && responses.length > 0) {
                                // Update counter and message
                                updateResponseCounter(messageRefs, responses.length, mentions.length);
                                updateAIMessage(messageRefs, `Received ${responses.length} responses. Summarizing...`);
                                
                                // Call summarize endpoint
                                const summarizeResponse = await fetch('/api/summarize', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                    },
                                    credentials: 'same-origin',
                                    body: JSON.stringify({ responses: responses }),
                                    signal: state.requestAbortController.signal
                                });
                                    
                                    if (summarizeResponse.ok) {
                                        // Handle streaming summary response
                                        const reader = summarizeResponse.body.getReader();
                                        const decoder = new TextDecoder();
                                        let summaryMessage = '';
                                        
                                        while (true) {
                                            const { done, value } = await reader.read();
                                            if (done) break;
                                            
                                            const chunk = decoder.decode(value);
                                            const lines = chunk.split('\n').filter(line => line.trim());
                                            
                                            for (const line of lines) {
                                                try {
                                                    const data = JSON.parse(line);
                                                    
                                                    if (data.type === 'start') {
                                                        summaryMessage = '';
                                                    } else if (data.type === 'chunk') {
                                                        summaryMessage += data.content;
                                                        updateAIMessage(messageRefs, summaryMessage);
                                                    }
                                                } catch (e) {
                                                    console.error('Error parsing JSON:', e);
                                                }
                                            }
                                        }
                                    } else {
                                        updateAIMessage(messageRefs, 'Failed to summarize responses.');
                                    }
                                } else {
                                    updateAIMessage(messageRefs, 'No responses received from peers.');
                                }
                            } else {
                                updateAIMessage(messageRefs, 'Failed to fetch peer responses.');
                            }
                        } else {
                            hideTyping();
                            addMessage('Sorry, failed to send query to peers.');
                        }
                    } else {
                        // Handle regular query response (streaming)
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let assistantMessage = '';
                        let messageRefs = null;
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            const chunk = decoder.decode(value);
                            const lines = chunk.split('\n').filter(line => line.trim());
                            
                            for (const line of lines) {
                                try {
                                    const data = JSON.parse(line);
                                    
                                    if (data.type === 'start' && data.status === 'success') {
                                        // Hide typing indicator and create AI message
                                        hideTyping();
                                        messageRefs = createAIMessage();
                                    } else if (data.type === 'chunk' && messageRefs) {
                                        assistantMessage += data.content;
                                        updateAIMessage(messageRefs, assistantMessage);
                                    } else if (data.status === 'error') {
                                        hideTyping();
                                        addMessage('Sorry, I encountered an error: ' + data.message);
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log('Request was cancelled');
                        } else {
                            hideTyping();
                            addMessage('Sorry, I couldn\'t connect to the server. Please try again.');
                            console.error('Error:', error);
                        }
                    }
                } finally {
                    state.isProcessingMessage = false;
                    state.requestAbortController = null;
                    chatInput.disabled = false;
                    updateSendButton();
                    chatInput.focus();
                    sendMessageMutex.release();
                }
            }
            
            // Event listener management
            function addEventListener(element, event, handler) {
                element.addEventListener(event, handler);
                state.eventListeners.push({ element, event, handler });
            }
            
            function removeAllEventListeners() {
                state.eventListeners.forEach(({ element, event, handler }) => {
                    element.removeEventListener(event, handler);
                });
                state.eventListeners = [];
            }
            
            // Event listeners
            addEventListener(chatInput, 'input', (e) => {
                autoResize();
                
                const cursorPosition = chatInput.selectionStart;
                const text = chatInput.value;
                
                // Check for @ character
                if (!state.mentionActive && !state.slashActive) {
                    const lastChar = text[cursorPosition - 1];
                    if (lastChar === '@') {
                        // Check if @ is at start or preceded by space
                        if (cursorPosition === 1 || text[cursorPosition - 2] === ' ' || text[cursorPosition - 2] === '\n') {
                            state.mentionActive = true;
                            state.mentionStartPosition = cursorPosition - 1;
                            state.selectedMentionIndex = 0;
                            updateMentionPopup();
                        }
                    } else if (lastChar === '/') {
                        // Check if / is at start or preceded by space
                        if (cursorPosition === 1 || text[cursorPosition - 2] === ' ' || text[cursorPosition - 2] === '\n') {
                            state.slashActive = true;
                            state.slashStartPosition = cursorPosition - 1;
                            state.selectedSlashIndex = 0;
                            updateSlashPopup();
                        }
                    }
                } else if (state.mentionActive) {
                    // Update mention filter
                    if (cursorPosition >= state.mentionStartPosition) {
                        const filter = text.substring(state.mentionStartPosition + 1, cursorPosition);
                        
                        // Hide popup if space is typed or cursor moved before @
                        if (filter.includes(' ') || cursorPosition <= state.mentionStartPosition) {
                            hideMentionPopup();
                        } else {
                            updateMentionPopup(filter);
                        }
                    } else {
                        hideMentionPopup();
                    }
                } else if (state.slashActive) {
                    // Update slash command filter
                    if (cursorPosition >= state.slashStartPosition) {
                        const filter = text.substring(state.slashStartPosition, cursorPosition);
                        
                        // Hide popup if space is typed or cursor moved before /
                        if (filter.includes(' ') || cursorPosition <= state.slashStartPosition) {
                            hideSlashPopup();
                        } else {
                            updateSlashPopup(filter);
                        }
                    } else {
                        hideSlashPopup();
                    }
                }
            });
            
            addEventListener(sendButton, 'click', sendMessage);
            
            addEventListener(chatInput, 'keydown', (e) => {
                if (state.mentionActive) {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        if (state.filteredUsers.length > 0) {
                            insertMention(state.filteredUsers[state.selectedMentionIndex]);
                        }
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        state.selectedMentionIndex = Math.min(state.selectedMentionIndex + 1, state.filteredUsers.length - 1);
                        updateMentionPopup(chatInput.value.substring(state.mentionStartPosition + 1, chatInput.selectionStart));
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        state.selectedMentionIndex = Math.max(state.selectedMentionIndex - 1, 0);
                        updateMentionPopup(chatInput.value.substring(state.mentionStartPosition + 1, chatInput.selectionStart));
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        hideMentionPopup();
                    } else if (e.key === 'Enter') {
                        if (state.filteredUsers.length > 0) {
                            e.preventDefault();
                            insertMention(state.filteredUsers[state.selectedMentionIndex]);
                        }
                    }
                } else if (state.slashActive) {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        if (state.filteredCommands.length > 0) {
                            insertSlashCommand(state.filteredCommands[state.selectedSlashIndex]);
                        }
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        state.selectedSlashIndex = Math.min(state.selectedSlashIndex + 1, state.filteredCommands.length - 1);
                        updateSlashPopup(chatInput.value.substring(state.slashStartPosition, chatInput.selectionStart));
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        state.selectedSlashIndex = Math.max(state.selectedSlashIndex - 1, 0);
                        updateSlashPopup(chatInput.value.substring(state.slashStartPosition, chatInput.selectionStart));
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        hideSlashPopup();
                    } else if (e.key === 'Enter') {
                        if (state.filteredCommands.length > 0) {
                            e.preventDefault();
                            insertSlashCommand(state.filteredCommands[state.selectedSlashIndex]);
                        }
                    }
                } else if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            // Hide popups when clicking outside
            addEventListener(document, 'click', (e) => {
                if (!chatInput.contains(e.target) && !mentionPopup.contains(e.target)) {
                    hideMentionPopup();
                }
                if (!chatInput.contains(e.target) && !slashPopup.contains(e.target)) {
                    hideSlashPopup();
                }
            });
            
            // Clear conversation function
            async function clearConversation() {
                try {
                    // Cancel any pending requests
                    if (state.requestAbortController) {
                        state.requestAbortController.abort();
                    }
                    
                    const response = await fetch('/api/clear-conversation', {
                        method: 'POST',
                        credentials: 'same-origin'  // Include cookies
                    });
                    
                    if (response.ok) {
                        // Clear chat messages except the greeting
                        const messages = chatMessages.querySelectorAll('.message-wrapper');
                        messages.forEach((msg, index) => {
                            if (index > 0) { // Keep the first greeting message
                                msg.remove();
                            }
                        });
                        
                        // Show confirmation message
                        addMessage('Conversation cleared. Starting fresh!', false);
                        
                        // Focus input
                        chatInput.focus();
                    } else {
                        console.error('Failed to clear conversation');
                    }
                } catch (error) {
                    console.error('Error clearing conversation:', error);
                }
            }
            
            // Clear conversation button
            addEventListener(clearButton, 'click', clearConversation);
            
            // Initialize greeting timestamp
            const greetingTime = document.getElementById('greeting-time');
            if (greetingTime) {
                greetingTime.textContent = formatTime(new Date());
            }
            
            // Cleanup function
            window.cleanupChatPage = function() {
                removeAllEventListeners();
                if (state.requestAbortController) {
                    state.requestAbortController.abort();
                }
            };
            
            // Initialize
            autoResize();
            updateSendButton();
            chatInput.focus();
            scrollToBottom();
            
            // Load conversation history on page load
            loadConversationHistory();
            
            // Fetch active users when page loads
            fetchActiveUsers();
            
            // Function to load conversation history
            async function loadConversationHistory() {
                try {
                    const response = await fetch('/api/conversation-history', {
                        credentials: 'same-origin'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.history && data.history.length > 0) {
                            // Clear the greeting message if we have history
                            chatMessages.innerHTML = '';
                            
                            // Add historical messages with timestamps
                            data.history.forEach(msg => {
                                addMessage(msg.content, msg.role === 'user', msg.timestamp);
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error loading conversation history:', error);
                }
            }
        };
        
        // Initialize when loaded
        window.initializeChatPage();
    </script>
</body>
</html>