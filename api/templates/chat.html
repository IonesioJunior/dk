<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat - Syft Agent</title>
    <style>
        .chat-wrapper {
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 0;
            margin: 0;
            background-color: transparent;
            overflow: hidden;
            position: relative;
        }
        
        .chat-controls {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            z-index: 10;
        }
        
        .clear-button {
            padding: 0.5rem 1rem;
            background-color: #f3f4f6;
            color: #374151;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        
        body.dark .clear-button {
            background-color: #374151;
            color: #f3f4f6;
            border-color: #4b5563;
        }
        
        .clear-button:hover {
            background-color: #e5e7eb;
        }
        
        body.dark .clear-button:hover {
            background-color: #4b5563;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 0;
            min-height: 0;
        }
        
        .message-wrapper {
            padding: 0.75rem 0;
            background-color: transparent;
        }
        
        .message-content {
            max-width: 48rem;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            gap: 1.5rem;
            transition: background-color 0.2s ease, padding 0.2s ease;
            cursor: pointer;
            border-radius: 0.5rem;
        }
        
        .message-content:hover {
            background-color: rgba(249, 250, 251, 0.8);
            padding: 0.75rem 1rem;
        }
        
        body.dark .message-content:hover {
            background-color: rgba(31, 41, 55, 0.6);
        }
        
        .avatar {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .avatar.user {
            background-color: #f3f4f6;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        
        .avatar.assistant {
            background-color: #4a90e2;
            color: white;
        }
        
        body.dark .avatar.user {
            background-color: #374151;
            color: #f3f4f6;
            border: 1px solid #4b5563;
        }
        
        body.dark .avatar.assistant {
            background-color: #2563eb;
            color: white;
        }
        
        .message-text {
            line-height: 1.75;
            flex: 1;
            color: #1f2937;
            white-space: pre-wrap;
            word-wrap: break-word;
            text-align: left;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
        }
        
        body.dark .message-text {
            color: #e5e7eb;
        }
        
        .message-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        
        .message-name {
            font-weight: 600;
            font-size: 0.875rem;
        }
        
        .message-name.user {
            color: #2563eb;
        }
        
        .message-name.assistant {
            color: #059669;
        }
        
        body.dark .message-name.user {
            color: #60a5fa;
        }
        
        body.dark .message-name.assistant {
            color: #34d399;
        }
        
        .message-time {
            font-size: 0.75rem;
            color: #9ca3af;
        }
        
        body.dark .message-time {
            color: #6b7280;
        }
        
        .chat-input-wrapper {
            padding: 1rem 0 1.5rem;
            background-color: transparent;
            position: relative;
            flex-shrink: 0;
        }
        
        .chat-input-container {
            max-width: 48rem;
            margin: 0 auto;
            padding: 0 1rem;
            position: relative;
        }
        
        .input-box {
            width: 100%;
            display: flex;
            align-items: center;
            border: 1px solid #d9d9e3;
            border-radius: 0.75rem;
            background-color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s;
        }
        
        body.dark .input-box {
            background-color: #2a2b32;
            border-color: #565869;
        }
        
        .input-box:focus-within {
            border-color: #4a90e2;
        }
        
        .chat-input {
            flex: 1;
            padding: 0.875rem 1rem;
            font-size: 1rem;
            border: none;
            background: transparent;
            outline: none;
            resize: none;
            line-height: 1.5;
            min-height: 24px;
            max-height: 120px;
        }
        
        body.dark .chat-input {
            color: #ececf1;
        }
        
        .chat-input::placeholder {
            color: #8e8ea0;
        }
        
        body.dark .chat-input::placeholder {
            color: #acacbe;
        }
        
        .send-button {
            padding: 0.5rem;
            margin: 0.5rem;
            background-color: transparent;
            color: #8e8ea0;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .send-button:hover:not(:disabled) {
            background-color: #f0f0f0;
            color: #333;
        }
        
        body.dark .send-button:hover:not(:disabled) {
            background-color: #565869;
            color: #ececf1;
        }
        
        .send-button.active {
            background-color: #4a90e2;
            color: white;
        }
        
        .send-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .typing-indicator {
            display: none;
        }
        
        .typing-indicator.active {
            display: block;
        }
        
        .typing-dots {
            display: inline-flex;
            gap: 4px;
            align-items: center;
            margin: 0;
        }
        
        .message-text .typing-dots {
            margin-top: 0.5rem;
        }
        
        .typing-dots span {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #666;
            animation: typing 1.4s infinite;
        }
        
        body.dark .typing-dots span {
            background-color: #999;
        }
        
        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-10px);
            }
        }
        
        /* Pulsing animation for peer query status */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }
        
        .peer-status {
            animation: pulse 1.5s ease-in-out infinite;
            color: #6b7280;
            font-weight: 500;
        }
        
        body.dark .peer-status {
            color: #e5e7eb;
        }
        
        /* Scrollbar styling - minimalist and modern */
        .chat-messages::-webkit-scrollbar {
            width: 4px;
        }
        
        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(156, 163, 175, 0.3);
            border-radius: 999px;
            transition: background 0.2s ease;
        }
        
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(156, 163, 175, 0.5);
        }
        
        body.dark .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
        }
        
        body.dark .chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Firefox scrollbar support */
        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
        }
        
        body.dark * {
            scrollbar-color: rgba(255, 255, 255, 0.1) transparent;
        }
        
        /* Mention suggestion popup styles */
        .mention-popup {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 20;
            max-height: 12rem;
            overflow-y: auto;
            display: none;
            bottom: 100%;
            left: 0;
            width: 200px;
            margin-bottom: 0.5rem;
        }
        
        body.dark .mention-popup {
            background: #2a2b32;
            border-color: #565869;
        }
        
        .mention-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background-color 0.15s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .mention-item:hover,
        .mention-item.selected {
            background-color: #f3f4f6;
        }
        
        body.dark .mention-item:hover,
        body.dark .mention-item.selected {
            background-color: #374151;
        }
        
        .mention-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #4a90e2;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            position: relative;
        }
        
        .online-indicator {
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #10b981;
            border: 2px solid white;
        }
        
        body.dark .online-indicator {
            border-color: #2a2b32;
        }
        
        .mention-name {
            font-size: 0.875rem;
            color: #374151;
        }
        
        body.dark .mention-name {
            color: #e5e7eb;
        }
        
        .mention-item.offline .mention-avatar {
            opacity: 0.7;
        }
        
        .mention-item.offline .mention-name {
            opacity: 0.7;
        }
        
        /* Slash command popup styles */
        .slash-popup {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 20;
            max-height: 16rem;
            overflow-y: auto;
            display: none;
            bottom: 100%;
            left: 0;
            right: 0;
            margin-bottom: 0.5rem;
        }
        
        body.dark .slash-popup {
            background: #2a2b32;
            border-color: #565869;
        }
        
        .slash-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background-color 0.15s;
            border-bottom: 1px solid #f3f4f6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }
        
        body.dark .slash-item {
            border-bottom-color: #374151;
        }
        
        .slash-item:last-child {
            border-bottom: none;
        }
        
        .slash-item:hover,
        .slash-item.selected {
            background-color: #f3f4f6;
        }
        
        body.dark .slash-item:hover,
        body.dark .slash-item.selected {
            background-color: #374151;
        }
        
        .slash-command {
            font-weight: 600;
            font-size: 0.875rem;
            color: #2563eb;
            flex-shrink: 0;
        }
        
        body.dark .slash-command {
            color: #60a5fa;
        }
        
        .slash-description {
            font-size: 0.75rem;
            color: #6b7280;
            line-height: 1.3;
            text-align: right;
        }
        
        body.dark .slash-description {
            color: #9ca3af;
        }
        
        /* Response counter tag styles */
        .response-counter {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.125rem 0.5rem;
            background-color: #e5e7eb;
            color: #6b7280;
            font-size: 0.75rem;
            font-weight: 500;
            border-radius: 0.375rem;
            margin-left: 0.5rem;
        }
        
        body.dark .response-counter {
            background-color: #374151;
            color: #9ca3af;
        }
        
        .response-counter i {
            width: 14px;
            height: 14px;
        }
        
        /* Error state styles */
        .error-message {
            color: #ef4444;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            display: none;
        }
        
        .error-message.active {
            display: block;
        }
        
        /* Removed loading indicator styles */
        
        /* Removed spinning animation */
    </style>
</head>
<body>
    <div class="chat-wrapper">
        <div class="chat-controls">
            <button class="clear-button" id="clear-conversation">New Conversation</button>
        </div>
        <div class="chat-messages" id="chat-messages">
            <div class="message-wrapper assistant">
                <div class="message-content">
                    <div class="avatar assistant">AI</div>
                    <div style="flex: 1;">
                        <div class="message-header">
                            <div class="message-name assistant">AI Assistant</div>
                            <div class="message-time" id="greeting-time"></div>
                        </div>
                        <div class="message-text">Hello! How can I help you today?</div>
                    </div>
                </div>
            </div>
            
            <div class="typing-indicator message-wrapper assistant" id="typing-indicator">
                <div class="message-content">
                    <div class="avatar assistant">AI</div>
                    <div class="message-text">
                        <div class="typing-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="chat-input-wrapper">
            <div class="chat-input-container">
                <div class="input-box">
                    <textarea 
                        class="chat-input" 
                        id="chat-input" 
                        placeholder="Send a message..."
                        rows="1"
                    ></textarea>
                    <button class="send-button" id="send-button">
                        <i data-lucide="send" style="width: 20px; height: 20px;"></i>
                    </button>
                </div>
                <div class="error-message" id="error-message"></div>
                <div class="mention-popup" id="mention-popup"></div>
                <div class="slash-popup" id="slash-popup"></div>
            </div>
        </div>
    </div>
    
    <script>
        'use strict';
        
        // State Machine Implementation
        class ChatStateMachine {
            constructor() {
                this.states = {
                    IDLE: 'idle',
                    TYPING: 'typing',
                    SENDING: 'sending',
                    RECEIVING: 'receiving',
                    ERROR: 'error',
                    MENTION_ACTIVE: 'mention_active',
                    SLASH_ACTIVE: 'slash_active'
                };
                
                this.currentState = this.states.IDLE;
                this.stateData = {};
                this.listeners = {};
            }
            
            transition(newState, data = {}) {
                const oldState = this.currentState;
                this.currentState = newState;
                this.stateData = { ...this.stateData, ...data };
                
                if (this.listeners[newState]) {
                    this.listeners[newState].forEach(callback => callback(oldState, data));
                }
            }
            
            onStateChange(state, callback) {
                if (!this.listeners[state]) {
                    this.listeners[state] = [];
                }
                this.listeners[state].push(callback);
            }
            
            getState() {
                return this.currentState;
            }
            
            getData() {
                return this.stateData;
            }
        }
        
        // Request Manager with cancellation support
        class RequestManager {
            constructor() {
                this.activeRequests = new Map();
            }
            
            async fetch(id, url, options = {}) {
                // Cancel any existing request with the same ID
                this.cancel(id);
                
                const controller = new AbortController();
                this.activeRequests.set(id, controller);
                
                try {
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    
                    this.activeRequests.delete(id);
                    return response;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log(`Request ${id} was cancelled`);
                    }
                    this.activeRequests.delete(id);
                    throw error;
                }
            }
            
            cancel(id) {
                const controller = this.activeRequests.get(id);
                if (controller) {
                    controller.abort();
                    this.activeRequests.delete(id);
                }
            }
            
            cancelAll() {
                this.activeRequests.forEach(controller => controller.abort());
                this.activeRequests.clear();
            }
        }
        
        // Event Manager for cleanup
        class EventManager {
            constructor() {
                this.listeners = [];
            }
            
            addEventListener(target, event, handler, options) {
                target.addEventListener(event, handler, options);
                this.listeners.push({ target, event, handler, options });
            }
            
            removeAllListeners() {
                this.listeners.forEach(({ target, event, handler, options }) => {
                    target.removeEventListener(event, handler, options);
                });
                this.listeners = [];
            }
        }
        
        // Configuration constants
        const CONFIG = {
            MESSAGE_CHUNK_DELAY: 0,
            DEBOUNCE_DELAY: 150,
            AUTO_SCROLL_THRESHOLD: 100,
            MAX_INPUT_HEIGHT: 120,
            RESPONSE_WAIT_TIME: 5000,
            POPUP_OFFSET: 8,
            MAX_MESSAGE_LENGTH: 4000,
            REQUEST_TIMEOUT: 30000,
            POLL_INITIAL_DELAY: 1000,
            POLL_MAX_DELAY: 5000,
            POLL_MAX_ATTEMPTS: 10
        };
        
        // Chat Application
        class ChatApplication {
            constructor() {
                // Core components
                this.stateMachine = new ChatStateMachine();
                this.requestManager = new RequestManager();
                this.eventManager = new EventManager();
                
                // DOM elements
                this.elements = this.initializeDOMElements();
                
                // State
                this.state = {
                    users: [],
                    currentUserId: null,
                    mentionContext: {
                        active: false,
                        startPosition: -1,
                        selectedIndex: 0,
                        filteredItems: []
                    },
                    slashContext: {
                        active: false,
                        startPosition: -1,
                        selectedIndex: 0,
                        filteredItems: []
                    },
                    commands: this.getSlashCommands(),
                    messageHistory: [],
                    pendingMessages: new Map()
                };
                
                // Background refresh timer
                this.userRefreshInterval = null;
                
                // Initialize
                this.initialize();
            }
            
            initializeDOMElements() {
                return {
                    chatMessages: document.getElementById('chat-messages'),
                    chatInput: document.getElementById('chat-input'),
                    sendButton: document.getElementById('send-button'),
                    typingIndicator: document.getElementById('typing-indicator'),
                    mentionPopup: document.getElementById('mention-popup'),
                    slashPopup: document.getElementById('slash-popup'),
                    clearButton: document.getElementById('clear-conversation'),
                    greetingTime: document.getElementById('greeting-time'),
                    errorMessage: document.getElementById('error-message')
                };
            }
            
            async initialize() {
                // Initialize Lucide icons
                lucide.createIcons();
                
                // Setup state machine listeners
                this.setupStateMachineListeners();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Initialize UI
                this.updateSendButton();
                this.autoResize();
                this.setGreetingTime();
                
                // Load initial data
                await this.loadInitialData();
                
                // Start background user refresh (every 30 seconds)
                this.userRefreshInterval = setInterval(() => {
                    this.fetchActiveUsers().then(usersResult => {
                        if (usersResult) {
                            this.state.users = usersResult.users;
                            this.state.currentUserId = usersResult.currentUserId;
                        }
                    });
                }, 30000);
                
                // Focus input
                this.elements.chatInput.focus();
                this.scrollToBottom();
            }
            
            setupStateMachineListeners() {
                this.stateMachine.onStateChange(this.stateMachine.states.SENDING, () => {
                    this.elements.chatInput.disabled = true;
                    this.elements.sendButton.disabled = true;
                    this.hideError();
                });
                
                this.stateMachine.onStateChange(this.stateMachine.states.IDLE, () => {
                    this.elements.chatInput.disabled = false;
                    this.updateSendButton();
                });
                
                this.stateMachine.onStateChange(this.stateMachine.states.ERROR, (oldState, data) => {
                    this.showError(data.message);
                    this.elements.chatInput.disabled = false;
                    this.updateSendButton();
                });
                
                this.stateMachine.onStateChange(this.stateMachine.states.MENTION_ACTIVE, () => {
                    this.elements.mentionPopup.style.display = 'block';
                });
                
                this.stateMachine.onStateChange(this.stateMachine.states.SLASH_ACTIVE, () => {
                    this.elements.slashPopup.style.display = 'block';
                });
            }
            
            setupEventListeners() {
                // Input events - no debounce for immediate trigger detection
                this.eventManager.addEventListener(this.elements.chatInput, 'input', 
                    this.handleInput.bind(this));
                
                // Send events
                this.eventManager.addEventListener(this.elements.sendButton, 'click', 
                    this.handleSend.bind(this));
                
                this.eventManager.addEventListener(this.elements.chatInput, 'keydown', 
                    this.handleKeyDown.bind(this));
                
                // Clear conversation
                this.eventManager.addEventListener(this.elements.clearButton, 'click', 
                    this.handleClearConversation.bind(this));
                
                // Click outside popups
                this.eventManager.addEventListener(document, 'click', 
                    this.handleDocumentClick.bind(this));
                
                // Window resize
                this.eventManager.addEventListener(window, 'resize', 
                    this.debounce(this.handleResize.bind(this), 100));
            }
            
            async loadInitialData() {
                try {
                    const [usersResult, historyResult] = await Promise.all([
                        this.fetchActiveUsers(),
                        this.loadConversationHistory()
                    ]);
                    
                    if (usersResult) {
                        this.state.users = usersResult.users;
                        this.state.currentUserId = usersResult.currentUserId;
                    }
                    
                    if (historyResult) {
                        this.renderConversationHistory(historyResult);
                    }
                } catch (error) {
                    console.error('Error loading initial data:', error);
                }
            }
            
            async fetchActiveUsers() {
                try {
                    const response = await this.requestManager.fetch('users', '/api/active-users', {
                        credentials: 'same-origin'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const users = [];
                        const currentUserId = data.current_user_id;
                        
                        // Process online users
                        if (data.online && Array.isArray(data.online)) {
                            data.online.forEach((username, index) => {
                                if (username !== currentUserId) {
                                    users.push({
                                        id: index + 1,
                                        name: username,
                                        avatar: username.substring(0, 2).toUpperCase(),
                                        online: true
                                    });
                                }
                            });
                        }
                        
                        // Process offline users
                        if (data.offline && Array.isArray(data.offline)) {
                            data.offline.forEach((username, index) => {
                                if (username !== currentUserId) {
                                    users.push({
                                        id: data.online.length + index + 1,
                                        name: username,
                                        avatar: username.substring(0, 2).toUpperCase(),
                                        online: false
                                    });
                                }
                            });
                        }
                        
                        return { users, currentUserId };
                    }
                } catch (error) {
                    console.error('Error fetching active users:', error);
                }
                return null;
            }
            
            async loadConversationHistory() {
                try {
                    const response = await this.requestManager.fetch('history', '/api/conversation-history', {
                        credentials: 'same-origin'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        return data.history || [];
                    }
                } catch (error) {
                    console.error('Error loading conversation history:', error);
                }
                return [];
            }
            
            renderConversationHistory(history) {
                if (history.length > 0) {
                    this.elements.chatMessages.innerHTML = '';
                    history.forEach(msg => {
                        this.addMessage(msg.content, msg.role === 'user', msg.timestamp);
                    });
                }
            }
            
            handleInput(event) {
                this.autoResize();
                this.updateSendButton();
                this.checkForTriggers();
            }
            
            handleKeyDown(event) {
                const currentState = this.stateMachine.getState();
                const mentionActive = currentState === this.stateMachine.states.MENTION_ACTIVE;
                const slashActive = currentState === this.stateMachine.states.SLASH_ACTIVE;
                
                if (mentionActive || slashActive) {
                    const context = mentionActive ? this.state.mentionContext : this.state.slashContext;
                    const popup = mentionActive ? 'mention' : 'slash';
                    
                    switch (event.key) {
                        case 'Tab':
                        case 'Enter':
                            event.preventDefault();
                            if (context.filteredItems.length > 0) {
                                this.selectPopupItem(popup, context.filteredItems[context.selectedIndex]);
                            }
                            break;
                        case 'ArrowDown':
                            event.preventDefault();
                            this.navigatePopup(popup, 1);
                            break;
                        case 'ArrowUp':
                            event.preventDefault();
                            this.navigatePopup(popup, -1);
                            break;
                        case 'Escape':
                            event.preventDefault();
                            this.hidePopup(popup);
                            break;
                    }
                } else if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    this.handleSend();
                }
            }
            
            checkForTriggers() {
                const cursorPosition = this.elements.chatInput.selectionStart;
                const text = this.elements.chatInput.value;
                const char = text[cursorPosition - 1];
                const currentState = this.stateMachine.getState();
                
                if (currentState === this.stateMachine.states.IDLE || currentState === this.stateMachine.states.TYPING) {
                    if (char === '@' && this.isValidTriggerPosition(text, cursorPosition)) {
                        this.showMentionPopup(cursorPosition - 1);
                    } else if (char === '/' && this.isValidTriggerPosition(text, cursorPosition)) {
                        this.showSlashPopup(cursorPosition - 1);
                    }
                } else {
                    this.updateActivePopup(cursorPosition);
                }
            }
            
            isValidTriggerPosition(text, position) {
                return position === 1 || 
                       text[position - 2] === ' ' || 
                       text[position - 2] === '\n';
            }
            
            showMentionPopup(startPosition) {
                // Use cached users for immediate display
                this.state.mentionContext = {
                    active: true,
                    startPosition,
                    selectedIndex: 0,
                    filteredItems: this.state.users
                };
                this.stateMachine.transition(this.stateMachine.states.MENTION_ACTIVE);
                this.updateMentionPopup();
                
                // Fetch fresh users in background without blocking popup display
                this.fetchActiveUsers().then(usersResult => {
                    if (usersResult && this.state.mentionContext.active) {
                        this.state.users = usersResult.users;
                        // Update popup if still active with fresh data
                        const text = this.elements.chatInput.value;
                        const filter = text.substring(
                            this.state.mentionContext.startPosition + 1, 
                            this.elements.chatInput.selectionStart
                        );
                        this.state.mentionContext.filteredItems = this.state.users.filter(user =>
                            user.name.toLowerCase().includes(filter.toLowerCase())
                        );
                        this.renderMentionPopup();
                    }
                });
            }
            
            showSlashPopup(startPosition) {
                this.state.slashContext = {
                    active: true,
                    startPosition,
                    selectedIndex: 0,
                    filteredItems: this.state.commands
                };
                this.stateMachine.transition(this.stateMachine.states.SLASH_ACTIVE);
                this.updateSlashPopup();
            }
            
            updateActivePopup(cursorPosition) {
                const currentState = this.stateMachine.getState();
                
                if (currentState === this.stateMachine.states.MENTION_ACTIVE) {
                    this.updateMentionPopup(cursorPosition);
                } else if (currentState === this.stateMachine.states.SLASH_ACTIVE) {
                    this.updateSlashPopup(cursorPosition);
                }
            }
            
            updateMentionPopup(cursorPosition) {
                const context = this.state.mentionContext;
                const text = this.elements.chatInput.value;
                
                // Check if the trigger character has been deleted
                if (text[context.startPosition] !== '@' || 
                    (cursorPosition && cursorPosition <= context.startPosition)) {
                    this.hidePopup('mention');
                    return;
                }
                
                const filter = text.substring(
                    context.startPosition + 1, 
                    cursorPosition || this.elements.chatInput.selectionStart
                );
                
                if (filter.includes(' ')) {
                    this.hidePopup('mention');
                    return;
                }
                
                context.filteredItems = this.state.users.filter(user =>
                    user.name.toLowerCase().includes(filter.toLowerCase())
                );
                
                this.renderMentionPopup();
            }
            
            updateSlashPopup(cursorPosition) {
                const context = this.state.slashContext;
                const text = this.elements.chatInput.value;
                
                // Check if the trigger character has been deleted
                if (text[context.startPosition] !== '/' || 
                    (cursorPosition && cursorPosition <= context.startPosition)) {
                    this.hidePopup('slash');
                    return;
                }
                
                const filter = text.substring(
                    context.startPosition,
                    cursorPosition || this.elements.chatInput.selectionStart
                );
                
                if (filter.includes(' ')) {
                    this.hidePopup('slash');
                    return;
                }
                
                context.filteredItems = this.state.commands.filter(cmd =>
                    cmd.command.toLowerCase().includes(filter.toLowerCase())
                );
                
                this.renderSlashPopup();
            }
            
            renderMentionPopup() {
                const context = this.state.mentionContext;
                const popup = this.elements.mentionPopup;
                
                if (context.filteredItems.length === 0) {
                    this.hidePopup('mention');
                    return;
                }
                
                popup.innerHTML = context.filteredItems.map((user, index) => {
                    const selected = index === context.selectedIndex ? 'selected' : '';
                    const offline = !user.online ? 'offline' : '';
                    
                    return `
                        <div class="mention-item ${selected} ${offline}" data-index="${index}">
                            <div class="mention-avatar">
                                ${user.avatar}
                                ${user.online ? '<div class="online-indicator"></div>' : ''}
                            </div>
                            <div class="mention-name">${this.sanitizeHTML(user.name)}</div>
                        </div>
                    `;
                }).join('');
                
                this.attachPopupItemListeners('mention');
            }
            
            renderSlashPopup() {
                const context = this.state.slashContext;
                const popup = this.elements.slashPopup;
                
                if (context.filteredItems.length === 0) {
                    this.hidePopup('slash');
                    return;
                }
                
                popup.innerHTML = context.filteredItems.map((cmd, index) => {
                    const selected = index === context.selectedIndex ? 'selected' : '';
                    
                    return `
                        <div class="slash-item ${selected}" data-index="${index}">
                            <div class="slash-command">${this.sanitizeHTML(cmd.command)}</div>
                            <div class="slash-description">${this.sanitizeHTML(cmd.description)}</div>
                        </div>
                    `;
                }).join('');
                
                this.attachPopupItemListeners('slash');
            }
            
            attachPopupItemListeners(type) {
                const popup = type === 'mention' ? this.elements.mentionPopup : this.elements.slashPopup;
                const items = popup.querySelectorAll(`.${type}-item`);
                
                items.forEach((item, index) => {
                    item.addEventListener('click', () => {
                        const context = type === 'mention' ? this.state.mentionContext : this.state.slashContext;
                        this.selectPopupItem(type, context.filteredItems[index]);
                    });
                });
            }
            
            selectPopupItem(type, item) {
                if (type === 'mention') {
                    this.insertMention(item);
                } else {
                    this.insertSlashCommand(item);
                }
            }
            
            insertMention(user) {
                const context = this.state.mentionContext;
                const text = this.elements.chatInput.value;
                const beforeMention = text.substring(0, context.startPosition);
                const afterMention = text.substring(this.elements.chatInput.selectionStart);
                
                this.elements.chatInput.value = beforeMention + '@' + user.name + ' ' + afterMention;
                const cursorPosition = beforeMention.length + user.name.length + 2;
                this.elements.chatInput.setSelectionRange(cursorPosition, cursorPosition);
                
                this.hidePopup('mention');
                this.autoResize();
                this.updateSendButton();
                this.elements.chatInput.focus();
            }
            
            insertSlashCommand(cmd) {
                const context = this.state.slashContext;
                const text = this.elements.chatInput.value;
                const beforeSlash = text.substring(0, context.startPosition);
                const afterSlash = text.substring(this.elements.chatInput.selectionStart);
                
                this.elements.chatInput.value = beforeSlash + cmd.command + ' ' + afterSlash;
                const cursorPosition = beforeSlash.length + cmd.command.length + 1;
                this.elements.chatInput.setSelectionRange(cursorPosition, cursorPosition);
                
                this.hidePopup('slash');
                this.autoResize();
                this.updateSendButton();
                this.elements.chatInput.focus();
            }
            
            navigatePopup(type, direction) {
                const context = type === 'mention' ? this.state.mentionContext : this.state.slashContext;
                const newIndex = context.selectedIndex + direction;
                
                if (newIndex >= 0 && newIndex < context.filteredItems.length) {
                    context.selectedIndex = newIndex;
                    if (type === 'mention') {
                        this.renderMentionPopup();
                    } else {
                        this.renderSlashPopup();
                    }
                }
            }
            
            hidePopup(type) {
                if (type === 'mention') {
                    this.elements.mentionPopup.style.display = 'none';
                    this.state.mentionContext.active = false;
                } else {
                    this.elements.slashPopup.style.display = 'none';
                    this.state.slashContext.active = false;
                }
                this.stateMachine.transition(this.stateMachine.states.IDLE);
            }
            
            async handleSend() {
                const message = this.elements.chatInput.value.trim();
                if (!message || this.stateMachine.getState() === this.stateMachine.states.SENDING) {
                    return;
                }
                
                if (message.length > CONFIG.MAX_MESSAGE_LENGTH) {
                    this.showError(`Message too long. Maximum ${CONFIG.MAX_MESSAGE_LENGTH} characters.`);
                    return;
                }
                
                this.stateMachine.transition(this.stateMachine.states.SENDING);
                
                // Clear input
                this.elements.chatInput.value = '';
                this.autoResize();
                
                // Add user message
                this.addMessage(message, true);
                
                // Extract mentions
                const mentions = this.extractMentions(message);
                
                // Show typing indicator
                this.showTyping();
                
                try {
                    const endpoint = mentions.length > 0 ? '/api/query_peers' : '/api/query';
                    const requestBody = mentions.length > 0 
                        ? { message, peers: mentions }
                        : { message };
                    
                    const response = await this.requestManager.fetch('message', endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'same-origin',
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    if (mentions.length > 0) {
                        await this.handlePeerResponse(response, mentions);
                    } else {
                        await this.handleStreamingResponse(response);
                    }
                    
                    this.stateMachine.transition(this.stateMachine.states.IDLE);
                } catch (error) {
                    console.error('Error sending message:', error);
                    this.stateMachine.transition(this.stateMachine.states.ERROR, {
                        message: 'Failed to send message. Please try again.'
                    });
                    this.hideTyping();
                    this.addMessage('Sorry, I couldn\'t connect to the server. Please try again.', false);
                }
            }
            
            async handlePeerResponse(response, mentions) {
                const data = await response.json();
                
                if (data.status === 'success' && data.prompt_id) {
                    this.hideTyping();
                    const messageRefs = this.createAIMessage(mentions.length);
                    
                    // Wait for responses with polling
                    const responses = await this.pollForResponses(data.prompt_id, messageRefs, mentions);
                    
                    if (responses && responses.length > 0) {
                        this.updateResponseCounter(messageRefs, responses.length, mentions.length);
                        this.updateAIMessage(messageRefs, `Received ${responses.length} responses. Summarizing...`);
                        
                        // Call summarize endpoint
                        const summarizeResponse = await this.requestManager.fetch('summarize', '/api/summarize', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'same-origin',
                            body: JSON.stringify({ responses })
                        });
                        
                        if (summarizeResponse.ok) {
                            await this.handleStreamingResponse(summarizeResponse, messageRefs);
                        } else {
                            this.updateAIMessage(messageRefs, 'Failed to summarize responses.');
                        }
                    } else {
                        this.updateAIMessage(messageRefs, 'No responses received from peers.');
                    }
                } else {
                    this.hideTyping();
                    this.addMessage('Sorry, failed to send query to peers.', false);
                }
            }
            
            async pollForResponses(promptId, messageRefs, mentions) {
                let attempts = 0;
                let delay = CONFIG.POLL_INITIAL_DELAY;
                
                this.updateAIMessage(messageRefs, 'Gathering responses from peers...');
                
                while (attempts < CONFIG.POLL_MAX_ATTEMPTS) {
                    try {
                        const response = await this.requestManager.fetch(
                            `responses-${promptId}`,
                            `/api/prompt-responses/${promptId}`,
                            { credentials: 'same-origin' }
                        );
                        
                        if (response.ok) {
                            const data = await response.json();
                            
                            if (data.responses && data.responses.length > 0) {
                                return data.responses;
                            }
                        }
                        
                        attempts++;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay = Math.min(delay * 1.5, CONFIG.POLL_MAX_DELAY);
                    } catch (error) {
                        console.error('Error polling for responses:', error);
                        attempts++;
                    }
                }
                
                return null;
            }
            
            async handleStreamingResponse(response, existingMessageRefs = null) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let messageRefs = existingMessageRefs;
                let content = '';
                
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';
                        
                        for (const line of lines) {
                            if (line.trim()) {
                                try {
                                    const data = JSON.parse(line);
                                    
                                    if (data.type === 'start' && data.status === 'success' && !messageRefs) {
                                        this.hideTyping();
                                        messageRefs = this.createAIMessage();
                                    } else if (data.type === 'chunk' && messageRefs) {
                                        content += data.content;
                                        this.updateAIMessage(messageRefs, content);
                                    } else if (data.status === 'error') {
                                        this.hideTyping();
                                        this.addMessage('Sorry, I encountered an error: ' + data.message, false);
                                        return;
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                } finally {
                    reader.releaseLock();
                }
            }
            
            async handleClearConversation() {
                try {
                    const response = await this.requestManager.fetch('clear', '/api/clear-conversation', {
                        method: 'POST',
                        credentials: 'same-origin'
                    });
                    
                    if (response.ok) {
                        // Clear messages except greeting
                        const messages = this.elements.chatMessages.querySelectorAll('.message-wrapper');
                        messages.forEach((msg, index) => {
                            if (index > 0) {
                                msg.remove();
                            }
                        });
                        
                        // Show confirmation
                        this.addMessage('Conversation cleared. Starting fresh!', false);
                        
                        // Clear state
                        this.state.messageHistory = [];
                        
                        // Focus input
                        this.elements.chatInput.focus();
                    }
                } catch (error) {
                    console.error('Error clearing conversation:', error);
                    this.showError('Failed to clear conversation');
                }
            }
            
            handleDocumentClick(event) {
                const mentionPopup = this.elements.mentionPopup;
                const slashPopup = this.elements.slashPopup;
                const chatInput = this.elements.chatInput;
                
                if (!chatInput.contains(event.target)) {
                    if (!mentionPopup.contains(event.target)) {
                        this.hidePopup('mention');
                    }
                    if (!slashPopup.contains(event.target)) {
                        this.hidePopup('slash');
                    }
                }
            }
            
            handleResize() {
                this.autoResize();
                this.scrollToBottom();
            }
            
            // UI Helper Methods
            autoResize() {
                const input = this.elements.chatInput;
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, CONFIG.MAX_INPUT_HEIGHT) + 'px';
            }
            
            updateSendButton() {
                const hasText = this.elements.chatInput.value.trim().length > 0;
                this.elements.sendButton.disabled = !hasText;
                this.elements.sendButton.classList.toggle('active', hasText);
            }
            
            scrollToBottom() {
                const messages = this.elements.chatMessages;
                messages.scrollTop = messages.scrollHeight;
            }
            
            showTyping() {
                this.elements.typingIndicator.classList.add('active');
                this.scrollToBottom();
            }
            
            hideTyping() {
                this.elements.typingIndicator.classList.remove('active');
            }
            
            showError(message) {
                this.elements.errorMessage.textContent = message;
                this.elements.errorMessage.classList.add('active');
                setTimeout(() => this.hideError(), 5000);
            }
            
            hideError() {
                this.elements.errorMessage.classList.remove('active');
            }
            
            setGreetingTime() {
                if (this.elements.greetingTime) {
                    this.elements.greetingTime.textContent = this.formatTime(new Date());
                }
            }
            
            addMessage(content, isUser = false, timestamp = null) {
                const messageWrapper = document.createElement('div');
                messageWrapper.className = `message-wrapper ${isUser ? 'user' : 'assistant'}`;
                
                const time = timestamp ? new Date(timestamp) : new Date();
                
                messageWrapper.innerHTML = `
                    <div class="message-content">
                        <div class="avatar ${isUser ? 'user' : 'assistant'}">${isUser ? 'U' : 'AI'}</div>
                        <div style="flex: 1;">
                            <div class="message-header">
                                <div class="message-name ${isUser ? 'user' : 'assistant'}">
                                    ${isUser ? 'User' : 'AI Assistant'}
                                </div>
                                <div class="message-time">${this.formatTime(time)}</div>
                            </div>
                            <div class="message-text">${this.sanitizeHTML(content)}</div>
                        </div>
                    </div>
                `;
                
                // Insert before typing indicator if it exists
                const typingIndicator = this.elements.typingIndicator;
                if (typingIndicator && typingIndicator.parentNode === this.elements.chatMessages) {
                    this.elements.chatMessages.insertBefore(messageWrapper, typingIndicator);
                } else {
                    this.elements.chatMessages.appendChild(messageWrapper);
                }
                
                this.scrollToBottom();
                
                // Add to history
                this.state.messageHistory.push({
                    content,
                    isUser,
                    timestamp: time
                });
            }
            
            createAIMessage(mentionCount = 0) {
                const messageWrapper = document.createElement('div');
                messageWrapper.className = 'message-wrapper assistant';
                
                const responseCounterHTML = mentionCount > 0 ? `
                    <div class="response-counter">
                        <i data-lucide="user" style="width: 14px; height: 14px;"></i>
                        <span style="margin-left: 0.25rem;">0/${mentionCount}</span>
                    </div>
                ` : '';
                
                messageWrapper.innerHTML = `
                    <div class="message-content">
                        <div class="avatar assistant">AI</div>
                        <div style="flex: 1;">
                            <div class="message-header">
                                <div class="message-name assistant">AI Assistant</div>
                                <div class="message-time">${this.formatTime(new Date())}</div>
                                ${responseCounterHTML}
                            </div>
                            <div class="message-text">
                                <span class="typing-dots">
                                    <span></span>
                                    <span></span>
                                    <span></span>
                                </span>
                            </div>
                        </div>
                    </div>
                `;
                
                // Insert before typing indicator
                const typingIndicator = this.elements.typingIndicator;
                if (typingIndicator && typingIndicator.parentNode === this.elements.chatMessages) {
                    this.elements.chatMessages.insertBefore(messageWrapper, typingIndicator);
                } else {
                    this.elements.chatMessages.appendChild(messageWrapper);
                }
                
                this.scrollToBottom();
                
                // Initialize icons immediately
                lucide.createIcons({ container: messageWrapper });
                
                return {
                    messageElement: messageWrapper.querySelector('.message-text'),
                    responseCounter: messageWrapper.querySelector('.response-counter'),
                    typingDots: messageWrapper.querySelector('.typing-dots'),
                    wrapper: messageWrapper
                };
            }
            
            updateAIMessage(messageRefs, content) {
                const { messageElement, typingDots } = messageRefs;
                
                if (typingDots && typingDots.parentNode === messageElement) {
                    messageElement.removeChild(typingDots);
                }
                
                messageElement.textContent = content;
                
                // Apply pulsing animation for peer query status messages
                if (content.includes('Gathering responses from peers') || 
                    (content.includes('Received') && content.includes('responses. Summarizing'))) {
                    messageElement.classList.add('peer-status');
                } else {
                    messageElement.classList.remove('peer-status');
                }
                
                this.scrollToBottom();
            }
            
            updateResponseCounter(messageRefs, responseCount, totalMentions) {
                const { responseCounter } = messageRefs;
                if (responseCounter) {
                    responseCounter.querySelector('span').textContent = `${responseCount}/${totalMentions}`;
                }
            }
            
            extractMentions(message) {
                const mentionPattern = /@([a-zA-Z0-9_-]+)(?=\s|$|[.,!?])/g;
                const mentions = [];
                let match;
                
                while ((match = mentionPattern.exec(message)) !== null) {
                    const mention = match[1].trim();
                    if (mention && !mentions.includes(mention)) {
                        mentions.push(mention);
                    }
                }
                
                return mentions;
            }
            
            formatTime(date) {
                const now = new Date();
                const isToday = date.toDateString() === now.toDateString();
                
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes().toString().padStart(2, '0');
                const time = `${hours}:${minutes}`;
                
                if (isToday) {
                    return time;
                } else {
                    const month = date.toLocaleDateString('en-US', { month: 'short' });
                    const day = date.getDate();
                    return `${month} ${day}, ${time}`;
                }
            }
            
            sanitizeHTML(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
            
            getSlashCommands() {
                return [
                    { command: '/help', description: 'Show available commands and how to use them' },
                    { command: '/clear', description: 'Clear the current conversation' },
                    { command: '/model', description: 'Change the AI model being used' },
                    { command: '/settings', description: 'Open settings and configuration' },
                    { command: '/export', description: 'Export conversation history' },
                    { command: '/system', description: 'Set system prompt for the AI' },
                    { command: '/temperature', description: 'Adjust response randomness (0-1)' },
                    { command: '/history', description: 'View previous conversations' },
                    { command: '/search', description: 'Search through message history' },
                    { command: '/theme', description: 'Toggle between light and dark mode' }
                ];
            }
            
            // Cleanup method
            destroy() {
                this.requestManager.cancelAll();
                this.eventManager.removeAllListeners();
                if (this.userRefreshInterval) {
                    clearInterval(this.userRefreshInterval);
                }
            }
        }
        
        // Initialize the chat application
        window.chatApplication = new ChatApplication();
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (window.chatApplication) {
                window.chatApplication.destroy();
            }
        });
    </script>
</body>
</html>