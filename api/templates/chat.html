<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat - Syft Agent</title>
    <link rel="stylesheet" href="/static/css/chat_page.css">
    <link rel="stylesheet" href="/static/css/document-upload.css">
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- Include user avatar component -->
    <div style="display: none;">
        <div class="user-avatar-component">
            <style>
                /* Component-specific styles */
                .user-avatar-component {
                    position: relative;
                }
                
                .user-avatar {
                    width: 36px;
                    height: 36px;
                    border-radius: 50%;
                    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    transition: transform 0.2s ease, box-shadow 0.2s ease;
                }
                
                .user-avatar:hover {
                    transform: scale(1.05);
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                }
                
                .user-avatar-text {
                    color: #ffffff;
                    font-size: 14px;
                    font-weight: 600;
                }
                
                .user-dropdown {
                    position: absolute;
                    top: calc(100% + 8px);
                    right: 0;
                    background: white;
                    border: 1px solid #e5e7eb;
                    border-radius: 8px;
                    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
                    width: 200px;
                    padding: 8px;
                    z-index: 1000;
                    display: none;
                }
                
                .user-dropdown.show {
                    display: block;
                }
                
                .dark .user-dropdown {
                    background: #1f2937;
                    border-color: #374151;
                }
                
                .user-dropdown-item {
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    padding: 8px 12px;
                    border-radius: 6px;
                    cursor: pointer;
                    transition: background-color 0.2s ease;
                    color: #374151;
                }
                
                .dark .user-dropdown-item {
                    color: #d1d5db;
                }
                
                .user-dropdown-item:hover {
                    background-color: #f3f4f6;
                }
                
                .dark .user-dropdown-item:hover {
                    background-color: #374151;
                }
                
                .user-dropdown-divider {
                    height: 1px;
                    background: #e5e7eb;
                    margin: 8px 0;
                }
                
                .dark .user-dropdown-divider {
                    background: #374151;
                }
            </style>
            
            <div class="user-avatar" id="user-avatar">
                <span id="user-avatar-text" class="user-avatar-text">U</span>
            </div>
            
            <div class="user-dropdown" id="user-dropdown">
                <div class="user-dropdown-item" data-action="profile">
                    <i data-lucide="user" style="width: 16px; height: 16px;"></i>
                    <span>Profile</span>
                </div>
                <div class="user-dropdown-item" data-action="ai-assistant">
                    <i data-lucide="message-circle" style="width: 16px; height: 16px;"></i>
                    <span>AI Assistant</span>
                </div>
                <div class="user-dropdown-item" data-action="settings">
                    <i data-lucide="settings" style="width: 16px; height: 16px;"></i>
                    <span>Settings</span>
                </div>
                <div class="user-dropdown-item" data-action="documents">
                    <i data-lucide="file-text" style="width: 16px; height: 16px;"></i>
                    <span>Documents</span>
                </div>
                <div class="user-dropdown-item" data-action="theme" id="theme-dropdown-item">
                    <i data-lucide="sun" class="theme-icon" style="width: 16px; height: 16px;"></i>
                    <span>Light Theme</span>
                </div>
                <div class="user-dropdown-divider"></div>
                <div class="user-dropdown-item" data-action="signout">
                    <i data-lucide="log-out" style="width: 16px; height: 16px;"></i>
                    <span>Sign Out</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
    // User Avatar Component JavaScript
    (function() {
        window.userAvatarComponent = {
            init: function(containerId, options = {}) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                // Default options
                const defaults = {
                    username: 'User',
                    theme: 'light',
                    onProfileClick: null,
                    onAIAssistantClick: null,
                    onSettingsClick: null,
                    onDocumentsClick: null,
                    onSignOutClick: null,
                    onThemeToggle: null
                };
                
                const config = { ...defaults, ...options };
                
                // Clone the component template
                const componentTemplate = document.querySelector('.user-avatar-component');
                const component = componentTemplate.cloneNode(true);
                container.appendChild(component);
                
                // Get component elements
                const avatar = component.querySelector('#user-avatar');
                const avatarText = component.querySelector('#user-avatar-text');
                const dropdown = component.querySelector('#user-dropdown');
                const themeItem = component.querySelector('#theme-dropdown-item');
                
                // Set unique IDs to avoid conflicts
                const uniqueId = Date.now();
                avatar.id = `user-avatar-${uniqueId}`;
                avatarText.id = `user-avatar-text-${uniqueId}`;
                dropdown.id = `user-dropdown-${uniqueId}`;
                themeItem.id = `theme-dropdown-item-${uniqueId}`;
                
                // Set initial avatar text
                avatarText.textContent = config.username.substring(0, 2).toUpperCase();
                
                // Set initial theme
                userAvatarComponent.updateThemeItem(themeItem, config.theme);
                
                // Event listeners
                avatar.addEventListener('click', (e) => {
                    e.stopPropagation();
                    dropdown.classList.toggle('show');
                });
                
                // Handle dropdown item clicks
                component.querySelectorAll('.user-dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const action = item.dataset.action;
                        
                        dropdown.classList.remove('show');
                        
                        switch(action) {
                            case 'profile':
                                if (config.onProfileClick) config.onProfileClick();
                                break;
                            case 'ai-assistant':
                                if (config.onAIAssistantClick) {
                                    config.onAIAssistantClick();
                                } else if (window.loadContent) {
                                    // Use the global loadContent function if available
                                    window.loadContent('/chat');
                                } else if (window.parent && window.parent.loadContent) {
                                    // If we're in an iframe, use parent's loadContent
                                    window.parent.loadContent('/chat');
                                } else {
                                    // We're already on chat, so just close the dropdown
                                    dropdown.classList.remove('show');
                                }
                                break;
                            case 'settings':
                                if (config.onSettingsClick) config.onSettingsClick();
                                break;
                            case 'documents':
                                if (config.onDocumentsClick) {
                                    config.onDocumentsClick();
                                } else if (window.loadContent) {
                                    // Use the global loadContent function if available
                                    window.loadContent('/documents');
                                } else if (window.parent && window.parent.loadContent) {
                                    // If we're in an iframe, use parent's loadContent
                                    window.parent.loadContent('/documents');
                                } else {
                                    // Fallback to direct navigation
                                    window.location.href = '/documents';
                                }
                                break;
                            case 'theme':
                                const newTheme = config.theme === 'dark' ? 'light' : 'dark';
                                config.theme = newTheme;
                                userAvatarComponent.updateThemeItem(themeItem, newTheme);
                                if (config.onThemeToggle) config.onThemeToggle(newTheme);
                                break;
                            case 'signout':
                                if (config.onSignOutClick) config.onSignOutClick();
                                break;
                        }
                    });
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!component.contains(e.target)) {
                        dropdown.classList.remove('show');
                    }
                });
                
                // Initialize Lucide icons for this component
                if (window.lucide) {
                    lucide.createIcons({ container: component });
                }
                
                // Return API for external control
                const componentAPI = {
                    updateUsername: (username) => {
                        avatarText.textContent = username.substring(0, 2).toUpperCase();
                    },
                    updateTheme: (theme) => {
                        config.theme = theme;
                        userAvatarComponent.updateThemeItem(themeItem, theme);
                    },
                    closeDropdown: () => {
                        dropdown.classList.remove('show');
                    },
                    destroy: () => {
                        component.remove();
                    }
                };
                
                return componentAPI;
            },
            
            updateThemeItem: function(themeItem, currentTheme) {
                const isDark = currentTheme === 'dark';
                const text = themeItem.querySelector('span');
                
                if (text) {
                    text.textContent = isDark ? 'Light Theme' : 'Dark Theme';
                    
                    const existingIcon = themeItem.querySelector('i, svg');
                    if (existingIcon) {
                        const newIcon = document.createElement('i');
                        newIcon.setAttribute('data-lucide', isDark ? 'sun' : 'moon');
                        newIcon.style.width = '16px';
                        newIcon.style.height = '16px';
                        newIcon.className = 'theme-icon';
                        
                        existingIcon.parentNode.replaceChild(newIcon, existingIcon);
                        
                        if (window.lucide) {
                            lucide.createIcons({ container: themeItem });
                        }
                    }
                }
            }
        };
    })();
    </script>
    
    <!-- Include document upload component -->
    <div style="display: none;">
        {% include 'components/document_upload.html' %}
    </div>
</head>
<body>
    <div class="chat-wrapper">
        <div class="chat-controls">
            <div class="dropdown-container">
                <button class="dropdown-button" id="provider-dropdown-btn">
                    <span id="selected-provider">Loading...</span>
                    <i data-lucide="chevron-down" class="dropdown-arrow"></i>
                </button>
                <div class="dropdown-content" id="provider-dropdown">
                    <!-- Providers will be dynamically populated from API -->
                </div>
            </div>
            
            <div class="dropdown-container">
                <button class="dropdown-button" id="model-dropdown-btn">
                    <span id="selected-model">Loading...</span>
                    <i data-lucide="chevron-down" class="dropdown-arrow"></i>
                </button>
                <div class="dropdown-content" id="model-dropdown">
                    <!-- Models will be dynamically populated based on provider -->
                </div>
            </div>
        </div>
        
        <div class="top-right-controls">
            <div id="document-upload-container"></div>
            <div id="user-avatar-container"></div>
        </div>
        
        <!-- API Token Modal -->
        <div class="modal-overlay" id="api-token-modal">
            <div class="modal-content">
                <h3 class="modal-title">API Token Required</h3>
                <p class="modal-description">Please enter your API token for <span id="modal-provider-name"></span>:</p>
                <input type="password" class="modal-input" id="api-token-input" placeholder="sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx">
                <p class="modal-help" id="modal-help-text"></p>
                <div class="modal-buttons">
                    <button class="modal-button modal-button-secondary" id="modal-cancel">Cancel</button>
                    <button class="modal-button modal-button-primary" id="modal-save">Save</button>
                </div>
            </div>
        </div>
        <div class="chat-messages" id="chat-messages">
            <div class="message-wrapper assistant">
                <div class="message-content">
                    <div class="avatar assistant">AI</div>
                    <div style="flex: 1;">
                        <div class="message-header">
                            <div class="message-name assistant">AI Assistant</div>
                            <div class="message-time" id="greeting-time"></div>
                        </div>
                        <div class="message-text">Hello! How can I help you today?</div>
                    </div>
                </div>
            </div>
            
            <div class="typing-indicator message-wrapper assistant" id="typing-indicator">
                <div class="message-content">
                    <div class="avatar assistant">AI</div>
                    <div class="message-text">
                        <div class="typing-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="chat-input-wrapper">
            <div class="chat-input-container">
                <div class="input-box">
                    <textarea 
                        class="chat-input" 
                        id="chat-input" 
                        placeholder="Send a message..."
                        rows="1"
                    ></textarea>
                    <button class="send-button" id="send-button">
                        <i data-lucide="send" style="width: 20px; height: 20px;"></i>
                    </button>
                </div>
                <div class="error-message" id="error-message"></div>
                <div class="mention-popup" id="mention-popup"></div>
                <div class="slash-popup" id="slash-popup"></div>
            </div>
        </div>
    </div>
    
    <script>
        'use strict';
        
        // Wrap entire code in IIFE to avoid global conflicts
        (function() {
            // State Machine Implementation
            class ChatStateMachine {
            constructor() {
                this.states = {
                    IDLE: 'idle',
                    TYPING: 'typing',
                    SENDING: 'sending',
                    RECEIVING: 'receiving',
                    ERROR: 'error',
                    MENTION_ACTIVE: 'mention_active',
                    SLASH_ACTIVE: 'slash_active'
                };
                
                this.currentState = this.states.IDLE;
                this.stateData = {};
                this.listeners = {};
            }
            
            transition(newState, data = {}) {
                const oldState = this.currentState;
                this.currentState = newState;
                this.stateData = { ...this.stateData, ...data };
                
                if (this.listeners[newState]) {
                    this.listeners[newState].forEach(callback => callback(oldState, data));
                }
            }
            
            onStateChange(state, callback) {
                if (!this.listeners[state]) {
                    this.listeners[state] = [];
                }
                this.listeners[state].push(callback);
            }
            
            getState() {
                return this.currentState;
            }
            
            getData() {
                return this.stateData;
            }
        }
        
        // Request Manager with cancellation support
        class RequestManager {
            constructor() {
                this.activeRequests = new Map();
            }
            
            async fetch(id, url, options = {}) {
                // Cancel any existing request with the same ID
                this.cancel(id);
                
                const controller = new AbortController();
                this.activeRequests.set(id, controller);
                
                try {
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    
                    this.activeRequests.delete(id);
                    return response;
                } catch (error) {
                    this.activeRequests.delete(id);
                    // Silently handle abort errors (they're expected during navigation)
                    if (error.name === 'AbortError') {
                        throw error;
                    }
                    throw error;
                }
            }
            
            cancel(id) {
                const controller = this.activeRequests.get(id);
                if (controller) {
                    controller.abort();
                    this.activeRequests.delete(id);
                }
            }
            
            cancelAll() {
                this.activeRequests.forEach(controller => controller.abort());
                this.activeRequests.clear();
            }
        }
        
        // Event Manager for cleanup
        class EventManager {
            constructor() {
                this.listeners = [];
            }
            
            addEventListener(target, event, handler, options) {
                target.addEventListener(event, handler, options);
                this.listeners.push({ target, event, handler, options });
            }
            
            removeAllListeners() {
                this.listeners.forEach(({ target, event, handler, options }) => {
                    target.removeEventListener(event, handler, options);
                });
                this.listeners = [];
            }
        }
        
        // Configuration constants
        const CONFIG = {
            MESSAGE_CHUNK_DELAY: 0,
            DEBOUNCE_DELAY: 150,
            AUTO_SCROLL_THRESHOLD: 100,
            MAX_INPUT_HEIGHT: 120,
            RESPONSE_WAIT_TIME: 5000,
            POPUP_OFFSET: 8,
            MAX_MESSAGE_LENGTH: 4000,
            REQUEST_TIMEOUT: 30000,
            POLL_INITIAL_DELAY: 1000,
            POLL_MAX_DELAY: 5000,
            POLL_MAX_ATTEMPTS: 10
        };
        
        // Chat Application
        class ChatApplication {
            constructor() {
                // Core components
                this.stateMachine = new ChatStateMachine();
                this.requestManager = new RequestManager();
                this.eventManager = new EventManager();
                
                // DOM elements
                this.elements = this.initializeDOMElements();
                
                // State
                this.state = {
                    users: [],
                    currentUserId: null,
                    mentionContext: {
                        active: false,
                        startPosition: -1,
                        selectedIndex: 0,
                        filteredItems: []
                    },
                    slashContext: {
                        active: false,
                        startPosition: -1,
                        selectedIndex: 0,
                        filteredItems: []
                    },
                    commands: this.getSlashCommands(),
                    messageHistory: [],
                    pendingMessages: new Map(),
                    selectedProvider: 'anthropic',
                    selectedModel: 'claude-3-sonnet',
                    models: [],  // Will be populated after provider config loads
                    providerModels: null,  // Will be populated from API
                    apiTokens: {
                        anthropic: '',
                        openai: '',
                        openrouter: ''
                    },
                    pendingProviderChange: null
                };
                
                // Background refresh timer
                this.userRefreshInterval = null;
                
                // Initialize
                this.initialize();
            }
            
            initializeDOMElements() {
                const elements = {
                    chatMessages: document.getElementById('chat-messages'),
                    chatInput: document.getElementById('chat-input'),
                    sendButton: document.getElementById('send-button'),
                    typingIndicator: document.getElementById('typing-indicator'),
                    mentionPopup: document.getElementById('mention-popup'),
                    slashPopup: document.getElementById('slash-popup'),
                    greetingTime: document.getElementById('greeting-time'),
                    errorMessage: document.getElementById('error-message'),
                    providerDropdownBtn: document.getElementById('provider-dropdown-btn'),
                    providerDropdown: document.getElementById('provider-dropdown'),
                    modelDropdownBtn: document.getElementById('model-dropdown-btn'),
                    modelDropdown: document.getElementById('model-dropdown'),
                    selectedProvider: document.getElementById('selected-provider'),
                    selectedModel: document.getElementById('selected-model'),
                    // User avatar elements will be handled by the modular component
                    userAvatarContainer: document.getElementById('user-avatar-container'),
                    apiTokenModal: document.getElementById('api-token-modal'),
                    modalProviderName: document.getElementById('modal-provider-name'),
                    apiTokenInput: document.getElementById('api-token-input'),
                    modalCancel: document.getElementById('modal-cancel'),
                    modalSave: document.getElementById('modal-save')
                };
                
                
                return elements;
            }
            
            async initialize() {
                // Initialize theme - prioritize body class over localStorage
                const currentBodyTheme = document.body.classList.contains('dark') ? 'dark' : 'light';
                
                // Update localStorage to match current body theme
                localStorage.setItem('theme', currentBodyTheme);
                
                // Initialize user avatar component
                this.userAvatarInstance = null;
                this.documentUploadInstance = null;
                this.initializeUserAvatar();
                
                // Initialize Lucide icons
                lucide.createIcons();
                
                // Re-query elements after Lucide icon initialization, as it might modify DOM
                this.elements.providerDropdownBtn = document.getElementById('provider-dropdown-btn');
                this.elements.modelDropdownBtn = document.getElementById('model-dropdown-btn');
                
                // Setup state machine listeners
                this.setupStateMachineListeners();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Initialize UI
                this.updateSendButton();
                this.autoResize();
                this.setGreetingTime();
                
                // Load initial data (including provider config)
                await this.loadInitialData();
                
                // Start background user refresh (every 30 seconds)
                this.userRefreshInterval = setInterval(() => {
                    this.fetchActiveUsers().then(usersResult => {
                        if (usersResult) {
                            this.state.users = usersResult.users;
                            this.state.currentUserId = usersResult.currentUserId;
                            this.updateUserAvatar();
                        }
                    });
                }, 30000);
                
                // Focus input
                this.elements.chatInput.focus();
                this.scrollToBottom();
            }
            
            setupStateMachineListeners() {
                this.stateMachine.onStateChange(this.stateMachine.states.SENDING, () => {
                    this.elements.chatInput.disabled = true;
                    this.elements.sendButton.disabled = true;
                    this.hideError();
                });
                
                this.stateMachine.onStateChange(this.stateMachine.states.IDLE, () => {
                    this.elements.chatInput.disabled = false;
                    this.updateSendButton();
                });
                
                this.stateMachine.onStateChange(this.stateMachine.states.ERROR, (oldState, data) => {
                    this.showError(data.message);
                    this.elements.chatInput.disabled = false;
                    this.updateSendButton();
                });
                
                this.stateMachine.onStateChange(this.stateMachine.states.MENTION_ACTIVE, () => {
                    this.elements.mentionPopup.style.display = 'block';
                });
                
                this.stateMachine.onStateChange(this.stateMachine.states.SLASH_ACTIVE, () => {
                    this.elements.slashPopup.style.display = 'block';
                });
            }
            
            setupEventListeners() {
                // Input events - no debounce for immediate trigger detection
                this.eventManager.addEventListener(this.elements.chatInput, 'input', 
                    this.handleInput.bind(this));
                
                // Send events
                this.eventManager.addEventListener(this.elements.sendButton, 'click', 
                    this.handleSend.bind(this));
                
                this.eventManager.addEventListener(this.elements.chatInput, 'keydown', 
                    this.handleKeyDown.bind(this));
                
                
                // Dropdown events
                this.eventManager.addEventListener(this.elements.providerDropdownBtn, 'click', 
                    (e) => this.toggleDropdown('provider', e));
                
                this.eventManager.addEventListener(this.elements.modelDropdownBtn, 'click', 
                    (e) => this.toggleDropdown('model', e));
                
                // Provider item clicks will be handled dynamically in renderProviderDropdown
                // Model item clicks will be handled dynamically in renderModelDropdown
                
                // User avatar events are handled by the modular component
                
                // Modal event listeners
                this.eventManager.addEventListener(this.elements.modalCancel, 'click', 
                    () => this.hideApiTokenModal());
                
                this.eventManager.addEventListener(this.elements.modalSave, 'click', 
                    async () => await this.saveApiToken());
                
                this.eventManager.addEventListener(this.elements.apiTokenInput, 'keydown', 
                    async (e) => {
                        if (e.key === 'Enter') {
                            await this.saveApiToken();
                        }
                    });
                
                
                // Click outside popups
                this.eventManager.addEventListener(document, 'click', 
                    this.handleDocumentClick.bind(this));
                
                // Window resize
                this.eventManager.addEventListener(window, 'resize', 
                    this.debounce(this.handleResize.bind(this), 100));
            }
            
            async loadInitialData() {
                try {
                    const [usersResult, historyResult, providerConfig] = await Promise.all([
                        this.fetchActiveUsers(),
                        this.loadConversationHistory(),
                        this.fetchProviderConfig()
                    ]);
                    
                    if (providerConfig) {
                        this.applyProviderConfig(providerConfig);
                    }
                    
                    if (usersResult) {
                        this.state.users = usersResult.users;
                        this.state.currentUserId = usersResult.currentUserId;
                        this.updateUserAvatar();
                    }
                    
                    if (historyResult) {
                        this.renderConversationHistory(historyResult);
                    }
                } catch (error) {
                    // Ignore abort errors during page navigation
                    if (error.name !== 'AbortError') {
                        console.error('Error loading initial data:', error);
                    }
                }
            }
            
            async fetchProviderConfig() {
                try {
                    const response = await this.requestManager.fetch('provider-config', '/api/config/provider', {
                        credentials: 'same-origin'
                    });
                    
                    if (response.ok) {
                        return await response.json();
                    }
                } catch (error) {
                    // Ignore abort errors during page navigation
                    if (error.name !== 'AbortError') {
                        console.error('Error fetching provider config:', error);
                    }
                }
                return null;
            }
            
            applyProviderConfig(config) {
                if (!config || !config.current_config) return;
                
                const currentConfig = config.current_config;
                
                // Update available providers and models from API
                if (config.providers) {
                    this.state.providerModels = config.providers;
                    
                    // Render provider dropdown
                    this.renderProviderDropdown();
                }
                
                // Update provider selection
                if (currentConfig.provider) {
                    this.state.selectedProvider = currentConfig.provider;
                    this.elements.selectedProvider.textContent = currentConfig.provider.charAt(0).toUpperCase() + currentConfig.provider.slice(1);
                    
                    // Update provider dropdown selection
                    const providerItems = this.elements.providerDropdown.querySelectorAll('.dropdown-item');
                    providerItems.forEach(item => {
                        item.classList.toggle('selected', item.dataset.provider === currentConfig.provider);
                    });
                }
                
                // Update models for current provider
                if (currentConfig.provider && config.providers && config.providers[currentConfig.provider]) {
                    const models = config.providers[currentConfig.provider];
                    this.state.models = models.map(modelId => ({
                        id: modelId,
                        name: this.formatModelName(modelId),
                        description: ''
                    }));
                    
                    // Update model dropdown
                    this.renderModelDropdown();
                    
                    // Set current model
                    if (currentConfig.model && models.includes(currentConfig.model)) {
                        this.state.selectedModel = currentConfig.model;
                        this.elements.selectedModel.textContent = this.formatModelName(currentConfig.model);
                        
                        // Update model dropdown selection
                        const modelItems = this.elements.modelDropdown.querySelectorAll('.dropdown-item');
                        modelItems.forEach(item => {
                            item.classList.toggle('selected', item.dataset.model === currentConfig.model);
                        });
                    }
                }
            }
            
            formatModelName(modelId) {
                // Convert model IDs to display names
                const modelNames = {
                    'claude-3-haiku-20240307': 'Claude 3 Haiku',
                    'claude-3-sonnet-20240229': 'Claude 3 Sonnet',
                    'claude-3-opus-20240229': 'Claude 3 Opus',
                    'claude-3-5-sonnet-20241022': 'Claude 3.5 Sonnet',
                    'gpt-3.5-turbo': 'GPT-3.5 Turbo',
                    'gpt-4': 'GPT-4',
                    'gpt-4-turbo': 'GPT-4 Turbo',
                    'llama-3.1-70b': 'Llama 3.1 70B',
                    'mixtral-8x7b': 'Mixtral 8x7B',
                    'llama-2-7b': 'Llama 2 7B',
                    'codellama-34b': 'Code Llama 34B'
                };
                
                return modelNames[modelId] || modelId;
            }
            
            renderProviderDropdown() {
                if (!this.state.providerModels) return;
                
                this.elements.providerDropdown.innerHTML = '';
                
                Object.keys(this.state.providerModels).forEach(provider => {
                    const item = document.createElement('div');
                    item.className = 'dropdown-item';
                    item.dataset.provider = provider;
                    
                    if (provider === this.state.selectedProvider) {
                        item.classList.add('selected');
                    }
                    
                    item.innerHTML = `<span>${provider.charAt(0).toUpperCase() + provider.slice(1)}</span>`;
                    
                    this.eventManager.addEventListener(item, 'click', async (e) => {
                        e.stopPropagation();
                        await this.selectProvider(provider);
                    });
                    
                    this.elements.providerDropdown.appendChild(item);
                });
            }
            
            async fetchActiveUsers() {
                try {
                    const response = await this.requestManager.fetch('users', '/api/active-users', {
                        credentials: 'same-origin'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const users = [];
                        const currentUserId = data.current_user_id;
                        
                        // Process online users
                        if (data.online && Array.isArray(data.online)) {
                            data.online.forEach((username, index) => {
                                if (username !== currentUserId) {
                                    users.push({
                                        id: index + 1,
                                        name: username,
                                        avatar: username.substring(0, 2).toUpperCase(),
                                        online: true
                                    });
                                }
                            });
                        }
                        
                        // Process offline users
                        if (data.offline && Array.isArray(data.offline)) {
                            data.offline.forEach((username, index) => {
                                if (username !== currentUserId) {
                                    users.push({
                                        id: data.online.length + index + 1,
                                        name: username,
                                        avatar: username.substring(0, 2).toUpperCase(),
                                        online: false
                                    });
                                }
                            });
                        }
                        
                        return { users, currentUserId };
                    }
                } catch (error) {
                    // Ignore abort errors during page navigation
                    if (error.name !== 'AbortError') {
                        console.error('Error fetching active users:', error);
                    }
                }
                return null;
            }
            
            async loadConversationHistory() {
                try {
                    const response = await this.requestManager.fetch('history', '/api/conversation-history', {
                        credentials: 'same-origin'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        return data.history || [];
                    }
                } catch (error) {
                    // Ignore abort errors during page navigation
                    if (error.name !== 'AbortError') {
                        console.error('Error loading conversation history:', error);
                    }
                }
                return [];
            }
            
            renderConversationHistory(history) {
                if (history.length > 0) {
                    this.elements.chatMessages.innerHTML = '';
                    history.forEach(msg => {
                        this.addMessage(msg.content, msg.role === 'user', msg.timestamp);
                    });
                }
            }
            
            handleInput(event) {
                this.autoResize();
                this.updateSendButton();
                this.checkForTriggers();
            }
            
            handleKeyDown(event) {
                const currentState = this.stateMachine.getState();
                const mentionActive = currentState === this.stateMachine.states.MENTION_ACTIVE;
                const slashActive = currentState === this.stateMachine.states.SLASH_ACTIVE;
                
                if (mentionActive || slashActive) {
                    const context = mentionActive ? this.state.mentionContext : this.state.slashContext;
                    const popup = mentionActive ? 'mention' : 'slash';
                    
                    switch (event.key) {
                        case 'Tab':
                        case 'Enter':
                            event.preventDefault();
                            if (context.filteredItems.length > 0) {
                                this.selectPopupItem(popup, context.filteredItems[context.selectedIndex]);
                            }
                            break;
                        case 'ArrowDown':
                            event.preventDefault();
                            this.navigatePopup(popup, 1);
                            break;
                        case 'ArrowUp':
                            event.preventDefault();
                            this.navigatePopup(popup, -1);
                            break;
                        case 'Escape':
                            event.preventDefault();
                            this.hidePopup(popup);
                            break;
                    }
                } else if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    this.handleSend();
                }
            }
            
            checkForTriggers() {
                const cursorPosition = this.elements.chatInput.selectionStart;
                const text = this.elements.chatInput.value;
                const char = text[cursorPosition - 1];
                const currentState = this.stateMachine.getState();
                
                if (currentState === this.stateMachine.states.IDLE || currentState === this.stateMachine.states.TYPING) {
                    if (char === '@' && this.isValidTriggerPosition(text, cursorPosition)) {
                        this.showMentionPopup(cursorPosition - 1);
                    } else if (char === '/' && this.isValidTriggerPosition(text, cursorPosition)) {
                        this.showSlashPopup(cursorPosition - 1);
                    }
                } else {
                    this.updateActivePopup(cursorPosition);
                }
            }
            
            isValidTriggerPosition(text, position) {
                return position === 1 || 
                       text[position - 2] === ' ' || 
                       text[position - 2] === '\n';
            }
            
            showMentionPopup(startPosition) {
                // Use cached users for immediate display
                this.state.mentionContext = {
                    active: true,
                    startPosition,
                    selectedIndex: 0,
                    filteredItems: this.state.users
                };
                this.stateMachine.transition(this.stateMachine.states.MENTION_ACTIVE);
                this.updateMentionPopup();
                
                // Fetch fresh users in background without blocking popup display
                this.fetchActiveUsers().then(usersResult => {
                    if (usersResult && this.state.mentionContext.active) {
                        this.state.users = usersResult.users;
                        // Update popup if still active with fresh data
                        const text = this.elements.chatInput.value;
                        const filter = text.substring(
                            this.state.mentionContext.startPosition + 1, 
                            this.elements.chatInput.selectionStart
                        );
                        this.state.mentionContext.filteredItems = this.state.users.filter(user =>
                            user.name.toLowerCase().includes(filter.toLowerCase())
                        );
                        this.renderMentionPopup();
                    }
                });
            }
            
            showSlashPopup(startPosition) {
                this.state.slashContext = {
                    active: true,
                    startPosition,
                    selectedIndex: 0,
                    filteredItems: this.state.commands
                };
                this.stateMachine.transition(this.stateMachine.states.SLASH_ACTIVE);
                this.updateSlashPopup();
            }
            
            updateActivePopup(cursorPosition) {
                const currentState = this.stateMachine.getState();
                
                if (currentState === this.stateMachine.states.MENTION_ACTIVE) {
                    this.updateMentionPopup(cursorPosition);
                } else if (currentState === this.stateMachine.states.SLASH_ACTIVE) {
                    this.updateSlashPopup(cursorPosition);
                }
            }
            
            updateMentionPopup(cursorPosition) {
                const context = this.state.mentionContext;
                const text = this.elements.chatInput.value;
                
                // Check if the trigger character has been deleted
                if (text[context.startPosition] !== '@' || 
                    (cursorPosition && cursorPosition <= context.startPosition)) {
                    this.hidePopup('mention');
                    return;
                }
                
                const filter = text.substring(
                    context.startPosition + 1, 
                    cursorPosition || this.elements.chatInput.selectionStart
                );
                
                if (filter.includes(' ')) {
                    this.hidePopup('mention');
                    return;
                }
                
                context.filteredItems = this.state.users.filter(user =>
                    user.name.toLowerCase().includes(filter.toLowerCase())
                );
                
                this.renderMentionPopup();
            }
            
            updateSlashPopup(cursorPosition) {
                const context = this.state.slashContext;
                const text = this.elements.chatInput.value;
                
                // Check if the trigger character has been deleted
                if (text[context.startPosition] !== '/' || 
                    (cursorPosition && cursorPosition <= context.startPosition)) {
                    this.hidePopup('slash');
                    return;
                }
                
                const filter = text.substring(
                    context.startPosition,
                    cursorPosition || this.elements.chatInput.selectionStart
                );
                
                if (filter.includes(' ')) {
                    this.hidePopup('slash');
                    return;
                }
                
                context.filteredItems = this.state.commands.filter(cmd =>
                    cmd.command.toLowerCase().includes(filter.toLowerCase())
                );
                
                this.renderSlashPopup();
            }
            
            renderMentionPopup() {
                const context = this.state.mentionContext;
                const popup = this.elements.mentionPopup;
                
                if (context.filteredItems.length === 0) {
                    this.hidePopup('mention');
                    return;
                }
                
                popup.innerHTML = context.filteredItems.map((user, index) => {
                    const selected = index === context.selectedIndex ? 'selected' : '';
                    const offline = !user.online ? 'offline' : '';
                    
                    return `
                        <div class="mention-item ${selected} ${offline}" data-index="${index}">
                            <div class="mention-avatar">
                                ${user.avatar}
                                ${user.online ? '<div class="online-indicator"></div>' : ''}
                            </div>
                            <div class="mention-name">${this.sanitizeHTML(user.name)}</div>
                        </div>
                    `;
                }).join('');
                
                this.attachPopupItemListeners('mention');
            }
            
            renderSlashPopup() {
                const context = this.state.slashContext;
                const popup = this.elements.slashPopup;
                
                if (context.filteredItems.length === 0) {
                    this.hidePopup('slash');
                    return;
                }
                
                popup.innerHTML = context.filteredItems.map((cmd, index) => {
                    const selected = index === context.selectedIndex ? 'selected' : '';
                    
                    return `
                        <div class="slash-item ${selected}" data-index="${index}">
                            <div class="slash-command">${this.sanitizeHTML(cmd.command)}</div>
                            <div class="slash-description">${this.sanitizeHTML(cmd.description)}</div>
                        </div>
                    `;
                }).join('');
                
                this.attachPopupItemListeners('slash');
            }
            
            attachPopupItemListeners(type) {
                const popup = type === 'mention' ? this.elements.mentionPopup : this.elements.slashPopup;
                const items = popup.querySelectorAll(`.${type}-item`);
                
                items.forEach((item, index) => {
                    item.addEventListener('click', () => {
                        const context = type === 'mention' ? this.state.mentionContext : this.state.slashContext;
                        this.selectPopupItem(type, context.filteredItems[index]);
                    });
                });
            }
            
            selectPopupItem(type, item) {
                if (type === 'mention') {
                    this.insertMention(item);
                } else {
                    this.insertSlashCommand(item);
                }
            }
            
            insertMention(user) {
                const context = this.state.mentionContext;
                const text = this.elements.chatInput.value;
                const beforeMention = text.substring(0, context.startPosition);
                const afterMention = text.substring(this.elements.chatInput.selectionStart);
                
                this.elements.chatInput.value = beforeMention + '@' + user.name + ' ' + afterMention;
                const cursorPosition = beforeMention.length + user.name.length + 2;
                this.elements.chatInput.setSelectionRange(cursorPosition, cursorPosition);
                
                this.hidePopup('mention');
                this.autoResize();
                this.updateSendButton();
                this.elements.chatInput.focus();
            }
            
            insertSlashCommand(cmd) {
                const context = this.state.slashContext;
                const text = this.elements.chatInput.value;
                const beforeSlash = text.substring(0, context.startPosition);
                const afterSlash = text.substring(this.elements.chatInput.selectionStart);
                
                // For commands that execute immediately, run them directly
                if (cmd.command === '/clear' || cmd.command === '/help' || cmd.command === '/theme') {
                    this.elements.chatInput.value = beforeSlash + afterSlash;
                    this.hidePopup('slash');
                    
                    // Execute the command
                    if (cmd.command === '/clear') {
                        this.handleClearConversation();
                    } else if (cmd.command === '/help') {
                        this.showHelpMessage();
                    } else if (cmd.command === '/theme') {
                        this.toggleTheme();
                    }
                    
                    this.autoResize();
                    this.updateSendButton();
                    this.elements.chatInput.focus();
                } else {
                    // For commands that might need parameters, insert them in the input
                    this.elements.chatInput.value = beforeSlash + cmd.command + ' ' + afterSlash;
                    const cursorPosition = beforeSlash.length + cmd.command.length + 1;
                    this.elements.chatInput.setSelectionRange(cursorPosition, cursorPosition);
                    
                    this.hidePopup('slash');
                    this.autoResize();
                    this.updateSendButton();
                    this.elements.chatInput.focus();
                }
            }
            
            navigatePopup(type, direction) {
                const context = type === 'mention' ? this.state.mentionContext : this.state.slashContext;
                const newIndex = context.selectedIndex + direction;
                
                if (newIndex >= 0 && newIndex < context.filteredItems.length) {
                    context.selectedIndex = newIndex;
                    if (type === 'mention') {
                        this.renderMentionPopup();
                    } else {
                        this.renderSlashPopup();
                    }
                }
            }
            
            hidePopup(type) {
                if (type === 'mention') {
                    this.elements.mentionPopup.style.display = 'none';
                    this.state.mentionContext.active = false;
                } else {
                    this.elements.slashPopup.style.display = 'none';
                    this.state.slashContext.active = false;
                }
                this.stateMachine.transition(this.stateMachine.states.IDLE);
            }
            
            async handleSend() {
                const message = this.elements.chatInput.value.trim();
                if (!message || this.stateMachine.getState() === this.stateMachine.states.SENDING) {
                    return;
                }
                
                // Handle slash commands
                if (message.startsWith('/')) {
                    const command = message.split(' ')[0].toLowerCase();
                    
                    switch (command) {
                        case '/clear':
                            this.elements.chatInput.value = '';
                            await this.handleClearConversation();
                            return;
                        case '/help':
                            this.showHelpMessage();
                            this.elements.chatInput.value = '';
                            return;
                        case '/theme':
                            this.toggleTheme();
                            this.elements.chatInput.value = '';
                            return;
                        // Add more slash command handlers here
                        default:
                            this.showError(`Unknown command: ${command}`);
                            this.elements.chatInput.value = '';
                            return;
                    }
                }
                
                if (message.length > CONFIG.MAX_MESSAGE_LENGTH) {
                    this.showError(`Message too long. Maximum ${CONFIG.MAX_MESSAGE_LENGTH} characters.`);
                    return;
                }
                
                this.stateMachine.transition(this.stateMachine.states.SENDING);
                
                // Clear input
                this.elements.chatInput.value = '';
                this.autoResize();
                
                // Add user message
                this.addMessage(message, true);
                
                // Extract mentions
                const mentions = this.extractMentions(message);
                
                // Show typing indicator
                this.showTyping();
                
                try {
                    const endpoint = mentions.length > 0 ? '/api/query_peers' : '/api/query';
                    const apiToken = this.state.apiTokens[this.state.selectedProvider] || '';
                    
                    const requestBody = mentions.length > 0 
                        ? { 
                            message, 
                            peers: mentions, 
                            provider: this.state.selectedProvider, 
                            model: this.state.selectedModel,
                            api_token: apiToken
                          }
                        : { 
                            message, 
                            provider: this.state.selectedProvider, 
                            model: this.state.selectedModel,
                            api_token: apiToken
                          };
                    
                    const response = await this.requestManager.fetch('message', endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'same-origin',
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    if (mentions.length > 0) {
                        await this.handlePeerResponse(response, mentions);
                    } else {
                        await this.handleStreamingResponse(response);
                    }
                    
                    this.stateMachine.transition(this.stateMachine.states.IDLE);
                } catch (error) {
                    console.error('Error sending message:', error);
                    this.stateMachine.transition(this.stateMachine.states.ERROR, {
                        message: 'Failed to send message. Please try again.'
                    });
                    this.hideTyping();
                    this.addMessage('Sorry, I couldn\'t connect to the server. Please try again.', false);
                }
            }
            
            async handlePeerResponse(response, mentions) {
                const data = await response.json();
                
                if (data.status === 'success' && data.prompt_id) {
                    this.hideTyping();
                    const messageRefs = this.createAIMessage(mentions.length);
                    
                    // Wait for responses with polling
                    const responses = await this.pollForResponses(data.prompt_id, messageRefs, mentions);
                    
                    if (responses && responses.length > 0) {
                        this.updateResponseCounter(messageRefs, responses.length, mentions.length);
                        this.updateAIMessage(messageRefs, `Received ${responses.length} responses. Summarizing...`);
                        
                        // Call summarize endpoint
                        const summarizeResponse = await this.requestManager.fetch('summarize', '/api/summarize', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'same-origin',
                            body: JSON.stringify({ responses })
                        });
                        
                        if (summarizeResponse.ok) {
                            await this.handleStreamingResponse(summarizeResponse, messageRefs);
                        } else {
                            this.updateAIMessage(messageRefs, 'Failed to summarize responses.');
                        }
                    } else {
                        this.updateAIMessage(messageRefs, 'No responses received from peers.');
                    }
                } else {
                    this.hideTyping();
                    this.addMessage('Sorry, failed to send query to peers.', false);
                }
            }
            
            async pollForResponses(promptId, messageRefs, mentions) {
                let attempts = 0;
                let delay = CONFIG.POLL_INITIAL_DELAY;
                
                this.updateAIMessage(messageRefs, 'Gathering responses from peers...');
                
                while (attempts < CONFIG.POLL_MAX_ATTEMPTS) {
                    try {
                        const response = await this.requestManager.fetch(
                            `responses-${promptId}`,
                            `/api/prompt-responses/${promptId}`,
                            { credentials: 'same-origin' }
                        );
                        
                        if (response.ok) {
                            const data = await response.json();
                            
                            if (data.responses && data.responses.length > 0) {
                                return data.responses;
                            }
                        }
                        
                        attempts++;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay = Math.min(delay * 1.5, CONFIG.POLL_MAX_DELAY);
                    } catch (error) {
                        console.error('Error polling for responses:', error);
                        attempts++;
                    }
                }
                
                return null;
            }
            
            async handleStreamingResponse(response, existingMessageRefs = null) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let messageRefs = existingMessageRefs;
                let content = '';
                
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';
                        
                        for (const line of lines) {
                            if (line.trim()) {
                                try {
                                    const data = JSON.parse(line);
                                    
                                    if (data.type === 'start' && data.status === 'success' && !messageRefs) {
                                        this.hideTyping();
                                        messageRefs = this.createAIMessage();
                                    } else if (data.type === 'chunk' && messageRefs) {
                                        content += data.content;
                                        this.updateAIMessage(messageRefs, content);
                                    } else if (data.status === 'error') {
                                        this.hideTyping();
                                        this.addMessage('Sorry, I encountered an error: ' + data.message, false);
                                        return;
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                } finally {
                    reader.releaseLock();
                }
            }
            
            async handleClearConversation() {
                try {
                    const response = await this.requestManager.fetch('clear', '/api/clear-conversation', {
                        method: 'POST',
                        credentials: 'same-origin'
                    });
                    
                    if (response.ok) {
                        // Clear messages except greeting
                        const messages = this.elements.chatMessages.querySelectorAll('.message-wrapper');
                        messages.forEach((msg, index) => {
                            if (index > 0) {
                                msg.remove();
                            }
                        });
                        
                        // Show confirmation
                        this.addMessage('Conversation cleared. Starting fresh!', false);
                        
                        // Clear state
                        this.state.messageHistory = [];
                        
                        // Focus input
                        this.elements.chatInput.focus();
                    }
                } catch (error) {
                    console.error('Error clearing conversation:', error);
                    this.showError('Failed to clear conversation');
                }
            }
            
            handleDocumentClick(event) {
                const mentionPopup = this.elements.mentionPopup;
                const slashPopup = this.elements.slashPopup;
                const chatInput = this.elements.chatInput;
                const providerDropdown = this.elements.providerDropdown;
                const modelDropdown = this.elements.modelDropdown;
                const providerBtn = this.elements.providerDropdownBtn;
                const modelBtn = this.elements.modelDropdownBtn;
                // User avatar click handling is managed by the component
                
                if (!chatInput.contains(event.target)) {
                    if (!mentionPopup.contains(event.target)) {
                        this.hidePopup('mention');
                    }
                    if (!slashPopup.contains(event.target)) {
                        this.hidePopup('slash');
                    }
                }
                
                // Handle dropdown clicks
                if (!providerBtn.contains(event.target) && !providerDropdown.contains(event.target)) {
                    this.closeDropdown('provider');
                }
                if (!modelBtn.contains(event.target) && !modelDropdown.contains(event.target)) {
                    this.closeDropdown('model');
                }
                // User dropdown is handled by the modular component
            }
            
            handleResize() {
                this.autoResize();
                this.scrollToBottom();
            }
            
            // UI Helper Methods
            autoResize() {
                const input = this.elements.chatInput;
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, CONFIG.MAX_INPUT_HEIGHT) + 'px';
            }
            
            updateSendButton() {
                const hasText = this.elements.chatInput.value.trim().length > 0;
                this.elements.sendButton.disabled = !hasText;
                this.elements.sendButton.classList.toggle('active', hasText);
            }
            
            scrollToBottom() {
                const messages = this.elements.chatMessages;
                messages.scrollTop = messages.scrollHeight;
            }
            
            showTyping() {
                this.elements.typingIndicator.classList.add('active');
                this.scrollToBottom();
            }
            
            hideTyping() {
                this.elements.typingIndicator.classList.remove('active');
            }
            
            showError(message) {
                this.elements.errorMessage.textContent = message;
                this.elements.errorMessage.classList.add('active');
                setTimeout(() => this.hideError(), 5000);
            }
            
            hideError() {
                this.elements.errorMessage.classList.remove('active');
            }
            
            showHelpMessage() {
                const helpText = `Available commands:
/clear - Clear the current conversation
/help - Show this help message
/model - Change the AI model
/settings - Open settings
/export - Export conversation history
/system - Set system prompt
/temperature - Adjust response randomness
/history - View previous conversations
/search - Search message history
/theme - Toggle dark/light mode`;
                
                this.addMessage(helpText, false);
            }
            
            setGreetingTime() {
                if (this.elements.greetingTime) {
                    this.elements.greetingTime.textContent = this.formatTime(new Date());
                }
            }
            
            addMessage(content, isUser = false, timestamp = null) {
                const messageWrapper = document.createElement('div');
                messageWrapper.className = `message-wrapper ${isUser ? 'user' : 'assistant'}`;
                
                const time = timestamp ? new Date(timestamp) : new Date();
                
                messageWrapper.innerHTML = `
                    <div class="message-content">
                        <div class="avatar ${isUser ? 'user' : 'assistant'}">${isUser ? 'U' : 'AI'}</div>
                        <div style="flex: 1;">
                            <div class="message-header">
                                <div class="message-name ${isUser ? 'user' : 'assistant'}">
                                    ${isUser ? 'User' : 'AI Assistant'}
                                </div>
                                <div class="message-time">${this.formatTime(time)}</div>
                            </div>
                            <div class="message-text">${this.sanitizeHTML(content)}</div>
                        </div>
                    </div>
                `;
                
                // Insert before typing indicator if it exists
                const typingIndicator = this.elements.typingIndicator;
                if (typingIndicator && typingIndicator.parentNode === this.elements.chatMessages) {
                    this.elements.chatMessages.insertBefore(messageWrapper, typingIndicator);
                } else {
                    this.elements.chatMessages.appendChild(messageWrapper);
                }
                
                this.scrollToBottom();
                
                // Add to history
                this.state.messageHistory.push({
                    content,
                    isUser,
                    timestamp: time
                });
            }
            
            createAIMessage(mentionCount = 0) {
                const messageWrapper = document.createElement('div');
                messageWrapper.className = 'message-wrapper assistant';
                
                const responseCounterHTML = mentionCount > 0 ? `
                    <div class="response-counter">
                        <i data-lucide="user" style="width: 14px; height: 14px;"></i>
                        <span style="margin-left: 0.25rem;">0/${mentionCount}</span>
                    </div>
                ` : '';
                
                messageWrapper.innerHTML = `
                    <div class="message-content">
                        <div class="avatar assistant">AI</div>
                        <div style="flex: 1;">
                            <div class="message-header">
                                <div class="message-name assistant">AI Assistant</div>
                                <div class="message-time">${this.formatTime(new Date())}</div>
                                ${responseCounterHTML}
                            </div>
                            <div class="message-text">
                                <span class="typing-dots">
                                    <span></span>
                                    <span></span>
                                    <span></span>
                                </span>
                            </div>
                        </div>
                    </div>
                `;
                
                // Insert before typing indicator
                const typingIndicator = this.elements.typingIndicator;
                if (typingIndicator && typingIndicator.parentNode === this.elements.chatMessages) {
                    this.elements.chatMessages.insertBefore(messageWrapper, typingIndicator);
                } else {
                    this.elements.chatMessages.appendChild(messageWrapper);
                }
                
                this.scrollToBottom();
                
                // Initialize icons immediately
                lucide.createIcons({ container: messageWrapper });
                
                return {
                    messageElement: messageWrapper.querySelector('.message-text'),
                    responseCounter: messageWrapper.querySelector('.response-counter'),
                    typingDots: messageWrapper.querySelector('.typing-dots'),
                    wrapper: messageWrapper
                };
            }
            
            updateAIMessage(messageRefs, content) {
                const { messageElement, typingDots } = messageRefs;
                
                if (typingDots && typingDots.parentNode === messageElement) {
                    messageElement.removeChild(typingDots);
                }
                
                messageElement.textContent = content;
                
                // Apply pulsing animation for peer query status messages
                if (content.includes('Gathering responses from peers') || 
                    (content.includes('Received') && content.includes('responses. Summarizing'))) {
                    messageElement.classList.add('peer-status');
                } else {
                    messageElement.classList.remove('peer-status');
                }
                
                this.scrollToBottom();
            }
            
            updateResponseCounter(messageRefs, responseCount, totalMentions) {
                const { responseCounter } = messageRefs;
                if (responseCounter) {
                    responseCounter.querySelector('span').textContent = `${responseCount}/${totalMentions}`;
                }
            }
            
            extractMentions(message) {
                const mentionPattern = /@([a-zA-Z0-9_-]+)(?=\s|$|[.,!?])/g;
                const mentions = [];
                let match;
                
                while ((match = mentionPattern.exec(message)) !== null) {
                    const mention = match[1].trim();
                    if (mention && !mentions.includes(mention)) {
                        mentions.push(mention);
                    }
                }
                
                return mentions;
            }
            
            formatTime(date) {
                const now = new Date();
                const isToday = date.toDateString() === now.toDateString();
                
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes().toString().padStart(2, '0');
                const time = `${hours}:${minutes}`;
                
                if (isToday) {
                    return time;
                } else {
                    const month = date.toLocaleDateString('en-US', { month: 'short' });
                    const day = date.getDate();
                    return `${month} ${day}, ${time}`;
                }
            }
            
            sanitizeHTML(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
            
            getSlashCommands() {
                return [
                    { command: '/clear', description: 'Clear the current conversation' },
                    { command: '/help', description: 'Show available commands and how to use them' },
                    { command: '/model', description: 'Change the AI model being used' },
                    { command: '/settings', description: 'Open settings and configuration' },
                    { command: '/export', description: 'Export conversation history' },
                    { command: '/system', description: 'Set system prompt for the AI' },
                    { command: '/temperature', description: 'Adjust response randomness (0-1)' },
                    { command: '/history', description: 'View previous conversations' },
                    { command: '/search', description: 'Search through message history' },
                    { command: '/theme', description: 'Toggle between light and dark mode' }
                ];
            }
            
            getModelsForProvider(provider) {
                // Use API data if available
                if (this.state && this.state.providerModels && this.state.providerModels[provider]) {
                    return this.state.providerModels[provider].map(modelId => ({
                        id: modelId,
                        name: this.formatModelName(modelId),
                        description: ''
                    }));
                }
                
                // Fallback to hardcoded values if API data not available
                const models = {
                    anthropic: [
                        { id: 'claude-3-sonnet', name: 'Claude 3.5 Sonnet', description: 'Most balanced model' },
                        { id: 'claude-3-opus', name: 'Claude 3 Opus', description: 'Most powerful' },
                        { id: 'claude-3-haiku', name: 'Claude 3 Haiku', description: 'Fastest model' }
                    ],
                    openai: [
                        { id: 'gpt-4', name: 'GPT-4', description: 'OpenAI\'s flagship' },
                        { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo', description: 'Fast and capable' }
                    ],
                    ollama: [
                        { id: 'llama-3.1-70b', name: 'Llama 3.1 70B', description: 'Meta\'s open model' },
                        { id: 'mixtral-8x7b', name: 'Mixtral 8x7B', description: 'MoE architecture' },
                        { id: 'llama-2-7b', name: 'Llama 2 7B', description: 'Smaller, faster' },
                        { id: 'codellama-34b', name: 'Code Llama 34B', description: 'Optimized for code' }
                    ],
                    openrouter: [
                        { id: 'claude-3-sonnet', name: 'Claude 3.5 Sonnet', description: 'Via OpenRouter' },
                        { id: 'gpt-4', name: 'GPT-4', description: 'Via OpenRouter' },
                        { id: 'llama-3.1-70b', name: 'Llama 3.1 70B', description: 'Via OpenRouter' },
                        { id: 'mistral-medium', name: 'Mistral Medium', description: 'Via OpenRouter' }
                    ]
                };
                
                return models[provider] || [];
            }
            
            // Dropdown methods
            toggleDropdown(type, event) {
                event.stopPropagation();
                const dropdown = type === 'provider' ? this.elements.providerDropdown : this.elements.modelDropdown;
                const otherDropdown = type === 'provider' ? this.elements.modelDropdown : this.elements.providerDropdown;
                const arrow = event.currentTarget.querySelector('.dropdown-arrow');
                
                // Close other dropdown
                otherDropdown.classList.remove('show');
                const otherArrow = (type === 'provider' ? this.elements.modelDropdownBtn : this.elements.providerDropdownBtn)
                    .querySelector('.dropdown-arrow');
                otherArrow.style.transform = 'rotate(0deg)';
                
                // Toggle current dropdown
                dropdown.classList.toggle('show');
                arrow.style.transform = dropdown.classList.contains('show') ? 'rotate(180deg)' : 'rotate(0deg)';
            }
            
            closeDropdown(type) {
                const dropdown = type === 'provider' ? this.elements.providerDropdown : this.elements.modelDropdown;
                const button = type === 'provider' ? this.elements.providerDropdownBtn : this.elements.modelDropdownBtn;
                const arrow = button.querySelector('.dropdown-arrow');
                
                dropdown.classList.remove('show');
                arrow.style.transform = 'rotate(0deg)';
            }
            
            async selectProvider(provider) {
                // Close the dropdown first
                this.closeDropdown('provider');
                
                if (provider === 'ollama') {
                    // For Ollama, patch config immediately
                    await this.patchProviderConfiguration(provider);
                } else if (this.state.apiTokens[provider]) {
                    // If we already have a token, proceed with existing token
                    this.confirmProviderChange(provider);
                } else {
                    // Show modal to ask for API token
                    this.state.pendingProviderChange = provider;
                    this.showApiTokenModal(provider);
                }
            }
            
            confirmProviderChange(provider) {
                this.state.selectedProvider = provider;
                this.elements.selectedProvider.textContent = provider.charAt(0).toUpperCase() + provider.slice(1);
                
                // Update selected state
                const items = this.elements.providerDropdown.querySelectorAll('.dropdown-item');
                items.forEach(item => {
                    item.classList.toggle('selected', item.dataset.provider === provider);
                });
                
                // Update available models for the new provider
                this.state.models = this.getModelsForProvider(provider);
                this.renderModelDropdown();
                
                // Reset model selection when changing provider
                this.resetModelSelection();
            }
            
            async selectModel(model, displayName) {
                const previousModel = this.state.selectedModel;
                this.state.selectedModel = model;
                
                // Extract just the model name without description
                const modelName = displayName.split('\n')[0].trim();
                this.elements.selectedModel.textContent = modelName;
                
                // Update selected state
                const items = this.elements.modelDropdown.querySelectorAll('.dropdown-item');
                items.forEach(item => {
                    item.classList.toggle('selected', item.dataset.model === model);
                });
                
                this.closeDropdown('model');
                
                // If the model actually changed, patch the configuration
                if (previousModel !== model) {
                    // Get the current provider's API token if needed
                    const apiToken = this.state.apiTokens[this.state.selectedProvider] || null;
                    await this.patchProviderConfiguration(this.state.selectedProvider, apiToken);
                }
            }
            
            renderModelDropdown() {
                const dropdown = this.elements.modelDropdown;
                dropdown.innerHTML = this.state.models.map((model, index) => {
                    const selected = this.state.selectedModel === model.id ? 'selected' : '';
                    return `
                        <div class="dropdown-item ${selected}" data-model="${model.id}">
                            <span>${model.name}</span>
                            <span class="model-description">${model.description}</span>
                        </div>
                    `;
                }).join('');
                
                // Re-attach event listeners
                const modelItems = dropdown.querySelectorAll('.dropdown-item');
                modelItems.forEach(item => {
                    item.addEventListener('click', async () => {
                        const model = this.state.models.find(m => m.id === item.dataset.model);
                        await this.selectModel(model.id, model.name);
                    });
                });
            }
            
            resetModelSelection() {
                // If we already have a selected model that's available in the current provider, keep it
                const currentModelAvailable = this.state.models.find(m => m.id === this.state.selectedModel);
                if (currentModelAvailable) {
                    this.selectModel(currentModelAvailable.id, currentModelAvailable.name);
                    return;
                }
                
                // Otherwise, set default model based on provider
                const defaultModels = {
                    'anthropic': 'claude-3-5-sonnet-20241022',
                    'openai': 'gpt-4',
                    'ollama': 'llama-3.1-70b',
                    'openrouter': 'claude-3-5-sonnet-20241022'
                };
                
                const defaultModelId = defaultModels[this.state.selectedProvider];
                const availableModel = this.state.models.find(m => m.id === defaultModelId);
                
                if (availableModel) {
                    this.selectModel(availableModel.id, availableModel.name);
                } else if (this.state.models.length > 0) {
                    // If default not available, select first available model
                    const firstModel = this.state.models[0];
                    this.selectModel(firstModel.id, firstModel.name);
                }
            }
            
            // Initialize user avatar component
            initializeUserAvatar() {
                if (window.userAvatarComponent) {
                    this.userAvatarInstance = window.userAvatarComponent.init('user-avatar-container', {
                        username: this.state.currentUserId || 'User',
                        theme: document.body.classList.contains('dark') ? 'dark' : 'light',
                        onProfileClick: () => {
                            console.log('Opening profile...');
                        },
                        onSettingsClick: () => {
                            console.log('Opening settings...');
                        },
                        onSignOutClick: () => {
                            console.log('Signing out...');
                        },
                        onThemeToggle: (theme) => {
                            this.toggleTheme();
                        }
                    });
                }
                
                // Initialize document upload component
                if (window.documentUploadComponent) {
                    this.documentUploadInstance = window.documentUploadComponent.init('document-upload-container', {
                        buttonText: 'Document',
                        acceptedFormats: '.txt',
                        multiple: true,
                        onUpload: async (files) => {
                            try {
                                // Prepare documents for bulk upload
                                const documents = files.map(file => ({
                                    file_name: file.name,
                                    content: file.content,
                                    metadata: {
                                        uploaded_by: this.state.currentUserId,
                                        uploaded_at: new Date().toISOString()
                                    }
                                }));
                                
                                const response = await this.requestManager.fetch('upload-documents', '/api/documents-collection/bulk', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                    },
                                    credentials: 'same-origin',
                                    body: JSON.stringify({ documents })
                                });
                                
                                if (response.ok) {
                                    const count = files.length;
                                    this.addMessage(`${count} document${count > 1 ? 's' : ''} uploaded successfully`, false);
                                    return true;
                                } else {
                                    const error = await response.json();
                                    this.showError(`Failed to upload documents: ${error.detail || 'Unknown error'}`);
                                    return false;
                                }
                            } catch (error) {
                                console.error('Error uploading documents:', error);
                                this.showError('Failed to upload documents');
                                return false;
                            }
                        }
                    });
                }
            }
            
            updateUserAvatar() {
                if (this.state.currentUserId && this.userAvatarInstance) {
                    this.userAvatarInstance.updateUsername(this.state.currentUserId);
                }
            }
            
            // Theme toggle method
            toggleTheme() {
                const isDark = document.body.classList.contains('dark');
                document.body.classList.toggle('dark');
                
                // Update icons and save preference
                const newTheme = !isDark ? 'dark' : 'light';
                localStorage.setItem('theme', newTheme);
                
                // Update the avatar component theme
                if (this.userAvatarInstance) {
                    this.userAvatarInstance.updateTheme(newTheme);
                }
                
                // Re-initialize lucide icons
                lucide.createIcons();
            }
            
            // API Token Modal methods
            showApiTokenModal(provider) {
                this.elements.modalProviderName.textContent = provider.charAt(0).toUpperCase() + provider.slice(1);
                this.elements.apiTokenInput.value = this.state.apiTokens[provider] || '';
                
                // Set help text based on provider
                const helpText = {
                    anthropic: 'Get your API key from console.anthropic.com/api-keys',
                    openai: 'Get your API key from platform.openai.com/api-keys',
                    openrouter: 'Get your API key from openrouter.ai/keys'
                };
                
                const modalHelpText = document.getElementById('modal-help-text');
                modalHelpText.textContent = helpText[provider] || 'Enter your API key for authentication.';
                
                this.elements.apiTokenModal.classList.add('show');
                this.elements.apiTokenInput.focus();
            }
            
            hideApiTokenModal() {
                this.elements.apiTokenModal.classList.remove('show');
                this.elements.apiTokenInput.value = '';
                this.state.pendingProviderChange = null;
            }
            
            async saveApiToken() {
                const provider = this.state.pendingProviderChange;
                const token = this.elements.apiTokenInput.value.trim();
                
                if (!token) {
                    this.showError('Please enter a valid API token');
                    return;
                }
                
                // Save token to state only (no localStorage)
                this.state.apiTokens[provider] = token;
                
                // Hide modal
                this.hideApiTokenModal();
                
                // Patch the configuration
                await this.patchProviderConfiguration(provider, token);
            }
            
            async patchProviderConfiguration(provider, apiToken = null) {
                try {
                    // Get the appropriate model for this provider
                    let model = '';
                    
                    // If we're switching to a new provider, get the first available model from API data
                    if (provider !== this.state.selectedProvider) {
                        if (this.state.providerModels && this.state.providerModels[provider] && this.state.providerModels[provider].length > 0) {
                            model = this.state.providerModels[provider][0];
                        } else {
                            // Fallback to hardcoded default models
                            const defaultModels = {
                                'anthropic': 'claude-3-sonnet-20240229',
                                'openai': 'gpt-4',
                                'ollama': 'llama3.2:3b-instruct-fp16',
                                'openrouter': 'claude-3-sonnet'
                            };
                            model = defaultModels[provider] || '';
                        }
                    } else {
                        // Use the currently selected model
                        model = this.state.selectedModel;
                    }
                    
                    // Build the configuration object
                    const config = {
                        provider: provider,
                        model: model,
                        parameters: {
                            temperature: 0.7  // Default temperature
                        }
                    };
                    
                    // Add API token if provided
                    if (apiToken) {
                        config.api_key = apiToken;
                    }
                    
                    // Make the PATCH request
                    const response = await this.requestManager.fetch('patch-config', '/api/config/provider', {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify(config)
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        // Configuration saved successfully
                        this.confirmProviderChange(provider);
                        
                        // Reload provider configuration to sync with server
                        const updatedConfig = await this.fetchProviderConfig();
                        if (updatedConfig) {
                            this.applyProviderConfig(updatedConfig);
                        }
                    } else {
                        this.showError('Failed to save configuration: ' + (result.message || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error patching provider configuration:', error);
                    this.showError('Failed to save configuration');
                }
            }
            
            // Cleanup method
            destroy() {
                this.requestManager.cancelAll();
                this.eventManager.removeAllListeners();
                if (this.userRefreshInterval) {
                    clearInterval(this.userRefreshInterval);
                }
                if (this.userAvatarInstance) {
                    this.userAvatarInstance.destroy();
                }
            }
        }
        
        // Only create a new instance if one doesn't exist
        if (!window.chatApplication) {
            window.chatApplication = new ChatApplication();
        }
        
        // Cleanup on page unload
        if (!window.chatCleanupRegistered) {
            window.addEventListener('beforeunload', () => {
                if (window.chatApplication) {
                    window.chatApplication.destroy();
                }
            });
            window.chatCleanupRegistered = true;
        }
        })(); // End IIFE
    </script>
</body>
</html>